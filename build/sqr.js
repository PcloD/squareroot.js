/* --- --- [SQR.js] --- --- */

/**
 *	@namespace SQR
 *	@description The global engine namesapce. All classes belong to this namespace.
 */
var SQR = {

	/**
	 *	@property TWOPI - shorthand for `Math.PI * 2`
	 */
	TWOPI: Math.PI * 2,

	/**
	 *	@property TWOPI - shorthand for `Math.PI * 0.5`
	 */
	HALFPI: Math.PI * 0.5,

	/**
	 *	@property EPSILON - a very small number, used to prevent rounding errors
	 */
	EPSILON: 1.0e-6,

	/**
	 *	@property gl - Placeholder that holds current gl context. This is set in SQR.Context.create(), but can be modified manually too
	 */
	gl: null, 
	
	/** 
	 *	@property fullScreenQuad - placeholder that holds a fullscreen geometry for post effects. Lazily created in PostEffect.js
	 *	Typically not set manually.
	 */
	fullScreenQuad: null,

	/**
	 *	@property shaderPath - a path relative to the main HTML file where the src/glsl folder is located.
	 *	Only necessary to if builtin shader code is loaded (using ~ paths).
	 *
	 *	@default .
	 */
	shaderPath: '.',

	/**
	 *	@namespace Primitives
	 *	@memberof SQR
	 *	@description A collection of classes & functions and utilities to create geometries
	 */
	Primitives: {},

	/**
	 *	@method v2
	 *	@memberof SQR
	 *
	 *	Shorthand for { aPosition: 2 }
	 */
	v2: function() { return { aPosition: 2 }; },

	/**
	 *	@method v2
	 *	@memberof SQR
	 *
	 *	Shorthand for { aPosition: 2 }
	 */
	v3: function() { return { aPosition: 3 }; },

	/**
	 *	@method v2
	 *	@memberof SQR
	 *
	 *	Shorthand for { aPosition: 2, aUV: 2 }
	 */
	v2u2: function() { return { aPosition: 2, aUV: 2 }; },

	/**
	 *	@method v2
	 *	@memberof SQR
	 *
	 *	Shorthand for { aPosition: 2, aColor: 3 }
	 */
	v2c3: function() { return { aPosition: 2, aColor: 3 }; },

	/**
	 *	@method v2
	 *	@memberof SQR
	 *
	 *	Shorthand for { aPosition: 3, aNormal: 3 }
	 */
	v3n3: function() { return { aPosition: 3, aNormal: 3 }; },

	/**
	 *	@method v2
	 *	@memberof SQR
	 *
	 *	Shorthand for { aPosition: 3, aNormal: 3, aUV: 2 }
	 */
	v3n3u2: function() { return { aPosition: 3, aNormal: 3, aUV: 2 }; },

    // Error reporting 

    // Issues a console.warn() is user attempts to set a uniform that does not exist on the shader
    WARN_UNIFORM_NOT_PRESENT : false 

};

/* --- --- [Version.js] --- --- */

/**
 *	@property Version - autogenerated with build script, holds current verison info
 */
// DO NOT EDIT. Updated from version.json
SQR.Version = {"version":"3","build":22,"date":"2015-02-21T09:02:50.770Z"}

/* --- --- [common/Buffer.js] --- --- */

/**
 *	@class Buffer
 *	@memberof SQR
 *
 *	@description A buffer represents a 2d or 3d geometry and an attribute buffer.
 *	A buffer is internally composed of a Float32Array array and a WebGL buffer object.
 *	Squareroot does rely on strides, so each geometry is only composed of one array/buffer.
 *	A stride is a portion of the array that holds data for all attributes in a specific order.
 *	For example if the geometry is composed of 3D vertices, normals and 2D UV coordinates, 
 *	the stride look like this<br>
 *	`vx, vy, vz, nx, ny, nz, u, v`<br>
 *	The creation of strides in handled internally by the Buffer class.
 *	<br><br>
 *	More info on strides can be found in the {@link https://www.khronos.org/registry/webgl/specs/latest/1.0/ specs}.
 *	<br><br>
 *	Please read the {@tutorial basic-setup} tutorial to see how to use a buffer  
 *	and the {@tutorial understanding-buffers} tutorial  for an in depth discussion on buffers.
 */
SQR.Buffer = function() {

	var b = {};
	var hasIndex = false;
	var data, indices;
	var buffer, indexBuffer;

	b.mode = SQR.gl.TRIANGLES;

	/**
	 *	@method setMode
	 *	@memberof SQR.Buffer.prototype
	 *
	 *	@description set the drawing mode for this buffer. 
	 *	Can be any one of the supported webgl drawing modes such as 
	 *	`gl.POINTS`, `gl.LINES` or `gl.TRIANGLES` which is the default.
	 *
	 *	Reminder: all the gl constants are available through the `SQR.gl` property.
	 */
	b.setMode = function(m) {
		b.mode = m
		return b;
	}

	/**
	 *	@method layout
	 *	@memberof SQR.Buffer.prototype
	 *	
	 *	@description Sets the layout of the buffer. 
	 *	A layout describes all the attributes of the geometry and their respective sizes. 
	 *	{@link SQR} has a few global functions that ar shorthands for typical layouts, like ex. {@link SQR.v2c3()}
	 *	@example 
var l = { aPosition: 3, aColor: 4, aUV: 2 };
// the `new` keyword is optional, all methods are chainable
var buffer = SQR.Buffer().layout(l, 100).update();
	 *
	 *	@param {object} layout - the layout of the buffer (see desc above) and {@tutorial understanding-buffers}
	 *	@param {Number} size - the size of the buffer i.e. how many vertices it has
	 *	
	 */
	b.layout = function(layout, size) {
		b.size = size;
		b.strideSize = 0;
		b.layout = layout;
		b.attributes = {};

		for(var a in layout) {
			var aa = { offset: b.strideSize, byteOffset: b.strideSize * 4, size: layout[a] };
			b.strideSize += layout[a];
			b.attributes[a] = aa;
		}

		b.strideByteSize = b.strideSize * 4;
		data = new Float32Array(size * b.strideSize);
		return b;
	}

	/**
	 *	@method data
	 *	@memberof SQR.Buffer.prototype
	 *
	 *	@description Sets all the data for a given attribute.
	 */
	b.data = function(attribute, array) {

		if(!(array instanceof Array)) {
			array = Array.prototype.slice.call(arguments, 1);
		}

		var s = b.attributes[attribute];
		var dl = array.length / s.size;

		for(var i = 0; i < dl; i++) {
			for(var j = 0; j < s.size; j++) {
				data[i * b.strideSize + j + s.offset] = array[i * s.size + j];
			}
		}

		return b;
	}

	/**
	 *	@method set
	 *	@memberof SQR.Buffer.prototype
	 *
	 *	@description Sets a value for an attribute at a defined position.
	 *
	 *	@param {string} attribute - name of the attribute (ex. `aPosition`)
	 *	@param {Number} position - the index of this attrbute (related to the size of the buffer)
	 *	@param {Array=} array - the data in form of an `Array` or as separate arguments 
	 *	or an object that has a `toArray` attribute (see example to see all the possible options)
	 *
	 *	@example
b.set('aPosition', 1, 	[3, 5, 6]);
b.set('aPosition', 1, 	4, 8, 9);
b.set('aPosition', 1, 	new SQR.V3(3, 5, 6));
	 */
	b.set = function(attribute, position, array) {
		if(array.toArray) {
			array = array.toArray();
		} else if(!(array instanceof Array)) {
			array = Array.prototype.slice.call(arguments, 2);
		}

		var s = b.attributes[attribute];

		for(var j = 0; j < s.size; j++) {
			data[position * b.strideSize + j + s.offset] = array[j];
		}

		return b;
	}

	/**
	 *	@method iterate
	 *	@memberof SQR.Buffer.prototype
	 *
	 *	@description Iterates over each value for a given attribute. 
	 *	See example to see how to move all the vertices by 4 on the Y axis.
	 *
	 *	@example
b.iterate('aPosition', function(i, data, count)) {
	// i = x, i+1 = y, i+2 = z
	data[i + 1] += 4;
});
	 */
	b.iterate = function(attribute, callback) {
		var s = b.attributes[attribute];
		var c = 0;

		for(var i = 0; i < data.length; i += b.strideSize) {
			callback(i + s.offset, data, c);
			c++;
		}
		return b;
	}

	/**
	 *	@method bind
	 *	@memberof SQR.Buffer.prototype
	 *
	 *	@description Binds the buffer in gl, 
	 *	which does the same thing as calling `gl.bindBuffer` directly.
	 */
	b.bind = function() {
		SQR.gl.bindBuffer(SQR.gl.ARRAY_BUFFER, buffer);
		return b;
	}

	/**
	 *	@method update
	 *	@memberof SQR.Buffer.prototype
	 *
	 *	@description Updates the webgl buffer with the data from the internal array. 
	 *	When called for the first time it lazily creates the webgl buffer.
	 */
	b.update = function() {
		var gl = SQR.gl;

		buffer = buffer || gl.createBuffer();
		gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW);

        if(hasIndex) {
        	indexBuffer = gl.createBuffer();
        	gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
        	gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);
        }

        return b;
	}

	/**
	 *	@method index
	 *	@memberof SQR.Buffer.prototype
	 *
	 *	@description Sets index data. 
	 *
	 *	@param {Array=} array either an array or argument list of all the indexes. 
	 *	Used when setting up meshes imported as OBJ or JSON object from Unity, Blender or similar.
	 */
	b.index = function(array) {

		if(!(array instanceof Array)) {
			array = Array.prototype.slice.call(arguments, 0);
		}

		indices = new Uint16Array(array);
		b.indexSize = array.length;
        hasIndex = true;

        return b;
	}

	/**
	 *	@method isIndexed
	 *	@memberof SQR.Buffer.prototype
	 *
	 *	@description returns true if buffer data is indexed and has an index array
	 */
	b.isIndexed = function() {
		return hasIndex;
	}

	/**
	 *	@method draw
	 *	@memberof SQR.Buffer.prototype
	 *
	 *	@description used by the {SQR.Renderer}, called when this geometry is drawn. 
	 *	Will call `gl.drawArrays` or `gl.drawElements` to draw the geometry using the current shader.
	 */
	b.draw = function() {
		var gl = SQR.gl;
		
		if(hasIndex)
			gl.drawElements(b.mode, b.indexSize, gl.UNSIGNED_SHORT, 0);
		else 
			gl.drawArrays(b.mode, 0, b.size);
	}

	/**
	 *	@method setRawData
	 *	@memberof SQR.Buffer.prototype
	 *
	 *	@description sets the raw data into the array at offset 
	 */
	b.setRawData = function(array, offset) {
		data.set(array, offset);
	}

	/**
	 *	@method getDataArray
	 *	@memberof SQR.Buffer.prototype
	 *
	 *	@description Returns the raw array data
	 *	
	 *	@data {Float32Array} - Array containing all the vertex attributes data organized in stride
	 *	according to the layout.
	 */
	b.getDataArray = function() {
		return data;
	}

	/**
	 *	@method destroy
	 *	@memberof SQR.Buffer.prototype
	 *
	 *	@description Destroys the buffer and clears all data from the array.
	 */
	b.destroy  = function() {
		data.length = 0;
		SQR.gl.deleteBuffer(buffer);

		if(hasIndex) {
			indices.length = 0;
			SQR.gl.deleteBuffer(indexBuffer);
		}
	}

	return b;

}

/* --- --- [common/Context.js] --- --- */

/**
 *	@class Context
 *	@memberof SQR
 *	
 *	@description When creating the Context object, a canvas element or a selector (ex. #gl-canvas) 
 *	can be passed to this function. If omitted a new canvas element will be created
 *	and it will be available as the canvas property of the object 
 *	returned by the SQR.Context functiom. See quick example below or read more in {@tutorial basic-setup}.
 *
 *	@example
// the `new` keyword is optional, all methods are chainable
var w = window.innerWidth, h = window.innerHeight;
var c = SQR.Context('#canvas').create().size(w, h).clearColor(0, 0, 0, 1);
 */
SQR.Context = function(canvas) {

	if(!SQR._versionDisplayed && SQR.Version) {
		console.log('Squareroot v' + SQR.Version.version + ' b' + SQR.Version.build);
		SQR._versionDisplayed = true;
	}
 
	var NOGL = "> SQR.Context - Webgl is not supported.";
	var BADCTX = "> SQR.Context - Invalid canvas reference.";

	if(!canvas) canvas = document.createElement('canvas');
	if(!(canvas instanceof HTMLElement)) canvas = document.querySelector(canvas);
	if(!canvas.getContext) throw BADCTX;

	var c = { 

		/**
		 *	@var {HTMLCanvasElement} canvas - Represents the canvas used to get the webgl context from.
		 *	@memberof SQR.Context.prototype
		 */
		canvas: canvas 
	}, gl;

	/**
	 *	@method create
	 *	@memberof SQR.Context.prototype
	 *	
	 *	@description Creates the webgl context. 
	 *	
	 *	@param options Options as defined in Specs, section 5.2.
	 *	Passing the options is not mandatory, if uses default values otherwise.
	 *	@link https://www.khronos.org/registry/webgl/specs/latest/1.0/#5.2
	 *	
	 *	@param onError callback in case WebGL is not supported
	 *	if ommited, this function will throw (see below) a error if there are problems.
	 *
	 *	@throws error is webgl context cannot be created (ex. webgl is not supported)
	 *
	 *	@returns SQR.Context
	 */
	c.create = function(options, onError) {

		onError = onError || function() { throw NOGL; };

		options = options || {};
		if(options.antialias === undefined) options.antialias = true;

		if(!window.WebGLRenderingContext) onError()

		try {
			gl = canvas.getContext('webgl', options) || canvas.getContext('experimental-webgl', options);
	    } catch(e) { 
	    	console.error(e);
	    	onError();
	    } 

		c.gl = gl;
        c.setAsCurrent();
		return c;
	}

	/** 
	 *	Sets the canvas and the viewport size to the given values.
	 */
	c.size = function(w, h) {
		canvas.width = w;
		canvas.height = h;
		gl.viewport(0, 0, w, h);
		return c;
	}

	/**
	 *	Define clear color. 
	 *	r, g, b, a are in [0-1] range.
	 */
	c.clearColor = function(r, g, b, a) {
		gl.clearColor(r, g, b, a);
		return c;
	}

	/**
	 *	Quick viewport clear function - clears both color and depth buffers.
	 *	Typically called at each frame before rendering to screen.
	 *	For custom clearing options use SQR.gl.clear()
	 */
	c.clear = function() {
		gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
		return c;
	}

	/**
	 *	Sets this context as current in the global SQR.gl variable.
	 *	This variable is used by the engine to perform rendering.
	 */
	c.setAsCurrent = function() {
		SQR.gl = gl;
		return c;
	}

	return c;
}

/* --- --- [common/Cubemap.js] --- --- */

/**
 *  @class Cubemap
 *  @memberof SQR
 *
 *  @descrption A cubemap texture is used for texturing reflections, skyboxes and similar effects. If your shader expects a cubemap uniform use this object to create one.
 *  @param faces {Object} 6 paths to the textures for each face.
 *  @param faces.up {string} the path to the image for the face up
 *  @param faces.down {string} the path to the image for the face down
 *  @param faces.left {string} the path to the image for the face left
 *  @param faces.right {string} the path to the image for the face right
 *  @param faces.back {string} the path to the image for the face back
 *  @param faces.front {string} the path to the image for the face front
 *
 *  @param params {object} parameter for the texture
 *  @param params.onLoad {function} a callback to call when all the images are loaded 
 */
SQR.Cubemap = function(faces, params) {

    var c = {};
    c.tex = SQR.gl.createTexture();

    var facesLeft = 6;
    var faceImages = {};

    params = params || {};

    var onLoad = function() {

    	var gl = SQR.gl;

        gl.bindTexture(gl.TEXTURE_CUBE_MAP, c.tex);

        // gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, c.flip);

        gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, faceImages.right);
        gl.texImage2D(gl.TEXTURE_CUBE_MAP_NEGATIVE_X, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, faceImages.left);

        gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_Y, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, faceImages.up);
        gl.texImage2D(gl.TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, faceImages.down);

        gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_Z, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, faceImages.front);
        gl.texImage2D(gl.TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, faceImages.back);

        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, gl.LINEAR);

        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

        gl.generateMipmap(gl.TEXTURE_CUBE_MAP);

        gl.bindTexture(gl.TEXTURE_CUBE_MAP, null);

        if (params.onLoad) params.onLoad();
    }

    var onFace = function() {
        facesLeft--;
        if (facesLeft <= 0) onLoad();
    }

    var load = function(name, src) {

        if (typeof(src) == "string") {
            faceImages[name] = new Image();
            faceImages[name].onload = onFace;
            faceImages[name].src = src;
        } else if (src instanceof Image || !!src.getContext) {
            faceImages[name] = src;
            onFace();
        }
    }

    if (faces.left) {
        load("left", faces.left);
        load("right", faces.right);
        load("up", faces.up);
        load("down", faces.down);
        load("back", faces.back);
        load("front", faces.front);
    } else {
        load("left", faces);
        load("right", faces);
        load("up", faces);
        load("down", faces);
        load("back", faces);
        load("front", faces);
    }

    return c;
}

/* --- --- [common/FrameBuffer.js] --- --- */

/**
 *  @class FrameBuffer
 *  @memberof SQR
 *  
 *  @description A FrameBuffer is used in render-to-texture, image effects and other advances rendering schemes.
 *
 *  @params width The width of the frame buffer
 *  @params height The height of the frame buffer
 */
SQR.FrameBuffer = function(width, height, resolution, isCubemap) {

    resolution = resolution || 1;

    var f = {}, gl = SQR.gl;

    f.texture = gl.createTexture();
    f.depthBuffer = gl.createRenderbuffer();

    // bind & setup texture
    if(!isCubemap) {
        f.fbo = gl.createFramebuffer();
        gl.bindFramebuffer(gl.FRAMEBUFFER, f.fbo);
        gl.bindTexture(gl.TEXTURE_2D, f.texture);

        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);

        // bind render buffer
        gl.bindRenderbuffer(gl.RENDERBUFFER, f.depthBuffer);
        gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, width, height);

        // attach texture and render buffer to fbo
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, f.texture, 0);
        gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, f.depthBuffer);

        // unbind all
        gl.bindTexture(gl.TEXTURE_2D, null);
        gl.bindRenderbuffer(gl.RENDERBUFFER, null);
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    } else {
        // based on http://jsperf.com/webgl-cubemap-fbo-change-face-test
        gl.bindTexture(gl.TEXTURE_CUBE_MAP, f.texture);

        // gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);

        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, gl.LINEAR);

        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

        for (var i = 0; i < 6; i++) {
            gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
        }
    
        gl.bindRenderbuffer(gl.RENDERBUFFER, f.depthBuffer);
        gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, width, height);
        
    
        var makeFace = function(index) {
            var fbo = gl.createFramebuffer();
            gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_CUBE_MAP_POSITIVE_X + index, f.texture, 0);
            gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, f.depthBuffer);
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            return fbo;
        };

        f.faces = {
            right: makeFace(0),
            left: makeFace(1),
            up: makeFace(2),
            down: makeFace(3),
            front: makeFace(4),
            back: makeFace(5),
        };

        gl.bindTexture(gl.TEXTURE_2D, null);
        gl.bindRenderbuffer(gl.RENDERBUFFER, null);
    }

    f.bind = function(name) {
        var fbo = (f.faces) ? f.faces[name] : f.fbo;
        gl.viewport(0, 0, width, height);
        gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
    }

    f.resize = function(w, h) {
        width = (w * resolution) | 0;
        height = (h * resolution) | 0;

        gl.bindFramebuffer(gl.FRAMEBUFFER, f.fbo);
        gl.bindTexture(gl.TEXTURE_2D, f.texture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);

        gl.bindRenderbuffer(gl.RENDERBUFFER, f.depthBuffer);
        gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, width, height);
    }

    return f;
}


/* --- --- [common/Loader.js] --- --- */

/**
 *	@namespace Loader
 *	@memberof SQR
 *
 *	@description Utility to load different types of files (and also some WebRTC related stuff, see below)
 */
SQR.Loader = {

	/** 
	 *	@method load
	 *	@memberof SQR.Loader
	 *
	 *	@description Load a text file and return it's contents in the callback.
	 */
	loadText: function(path, callback){
		var request = new XMLHttpRequest();
		request.open("GET", path);

		var onReadystatechange = function(){
			if (request.readyState == 4) {
				request.removeEventListener('readystatechange', onReadystatechange);
				callback(request.responseText, path);
			}
		}

		request.addEventListener('readystatechange', onReadystatechange);

		request.send();
	},

	/** 
	 *	@method loadJSON
	 *	@memberof SQR.Loader
	 *
	 *	@description Load a JSON file and return it's contents in the callback.
	 *	This function will parse the JSON data for you and return an Object.
	 */
	loadJSON: function(path, callback){
		SQR.Loader.loadText(path, function(text) {
			callback(JSON.parse(text), path);
		});
	},

	/** 
	 *	@method loadImage
	 *	@memberof SQR.Loader
	 *
	 *	@description Load an image file and return it's contents in the callback
	 *	as Image object.
	 */
	loadImage: function(path, callback){
		var img = new Image();
		if(callback) {
			var onload = function() {
				img.removeEventListener('load', onload);
				callback(img, path);
			}
			img.addEventListener('load', onload);
		}
		img.src = path;
		return img;
	},

	/** 
	 *	@method loadWebcam
	 *	@memberof SQR.Loader
	 *
	 *	@description Initiate user stream (webcam). 
	 */
	loadWebcam: function(callback, options) {
		navigator.getUserMedia  = navigator.getUserMedia ||
                                navigator.webkitGetUserMedia ||
                                navigator.mozGetUserMedia ||
                                navigator.msGetUserMedia;

        if(!navigator.getUserMedia) {
        	console.error('> SQR.Loader - getUserMedia not supported');
        	callback();
        }

        options = options || {
        	audio: false,
	        video: {
	        	// mandatory: { minWidth: 1920, minHeight: 1080 }
	        }
	    };

	    var onVideo = function(stream) {
	    	video.stream = stream;
			video.src = window.URL.createObjectURL(stream);
	        video.play();
	        video.addEventListener('canplaythrough', videoReady, false);
	    }

	    var videoReady = function() {
	    	callback(video, 'webcam');
	    }

        var video = document.createElement('video');
    	video.autoplay = true;

		navigator.getUserMedia(options, onVideo, function(e) { 
			console.error('> SQR.Loader - getUserMedia error ', e);
		});
    },

    /**
	 *	@method loadVideo
	 *	@memberof SQR.Loader
	 *
     *	@description Preload a video so that it can be used as a texture (typically)
     */
    loadVideo: function(path, callback) {
    	var videoReady = function() {
	    	callback(video, path);
	    }

    	var video = document.createElement('video');
    	video.autoplay = true;
    	video.addEventListener('canplaythrough', videoReady, false);


    	var p = path;

    	if(!video.canPlayType('video/mp4')) {
    		p = p.replace('mp4', 'webm');
    	}

    	video.src = p;
    },

    /**
	 *	@method loadAssets
	 *	@memberof SQR.Loader
	 *
     *	@description Load multiple assets of type:
     *  <ul>
     *		<li>text, including GLSL code</li>
     *		<li>JSON, including model, geometry, scene. etc...</li>
     *		<li>image (jpg, gif, png), video (mp4, webm)</li>
     *		<li>webcam (it will initiate the webcam,
     *		ask user for permisions, and return a ready to use stream)</li>
     *	</ul>
	 *	
	 *	Each file will be availabke from the asset object passed to the callback
	 *	under it's name, ex. assets['normal2color.glsl']
	 *	It's also possible ot specify an alias. Instead of a String, 
	 *	use an Array, where [0] is the path, and [1] is the alias.
     *
     *	@example
SQR.Loader.loadAssets([
	['some-image.jpg', 'image'],
	['some-video.mp4', 'video'],
	['a-shader.glsl', 'shader'],
	'another-shader.glsl',
	'webcam' // special case, but useful :)
], function(assets) {
	var image = assets['image'];
});
	 *
	 * 	@param {object} paths - list of file paths (with optinal aliases) to load, as in example below.
	 *	@param {function} callback - called when all the files are loaded. 
	 *	The assets are passed as argument as in the example below.
	 *	@param {function} progressCallback - called each time when on of the files is loaded
     */
	loadAssets: function(paths, callback, progressCallback) {
		var toLoad = paths.length;
		SQR.Loader.assets = {};
		var aliases = {};

		var onAsset = function(asset, p) {
			SQR.Loader.assets[aliases[p] || p] = asset;
			toLoad--;

			if(progressCallback) {
				progressCallback(toLoad, paths.length);
			}

			if(toLoad == 0) {
				callback(SQR.Loader.assets);
			}
		}
		
		for(var i = 0; i < toLoad; i++) {
			var p = paths[i];

			if(typeof(p) != 'string') {
				aliases[p[0]] = p[1];
				p = p[0];
			}

			var e = p.substring(p.lastIndexOf('.') + 1);

			if(p.indexOf('~') > -1) {
				if(SQR.GLSL && SQR.GLSL[p.substring(2)]) {
					toLoad--;
					continue;
				} else {
					p = p.replace('~', SQR.shaderPath);
				}
			}
			
			switch(e) {
				case 'glsl':
					SQR.Loader.loadText(p, onAsset);
					break;
				case 'png':
				case 'jpg':
				case 'gif':
					SQR.Loader.loadImage(p, onAsset);
					break;
				case 'json':
				case 'js':
					SQR.Loader.loadJSON(p, onAsset);
					break;
				case 'mp4':
				case 'webm':
					SQR.Loader.loadVideo(p, onAsset);
					break;
				case 'webcam':
					SQR.Loader.loadWebcam(onAsset);
					break;
			}
		}
	}
};








/* --- --- [common/Renderer.js] --- --- */

/**
 *	@class Renderer
 *	@memberof SQR
 *
 *	@description Represents the rendering engine
 */
SQR.Renderer = function(context) {

	var r = {};
	var uniforms = {}, renderObjects = [], transparentObjects = [];

	var updateTransform = function(t) {
		if(!t.active) return;

		t.transformWorld();
		
		if (t.numChildren > 0) {
            for (var i = 0; i < t.numChildren; i++) {
                updateTransform(t.children[i]);
            }
        }

        if(t.buffer && t.shader) {
        	if(t.transparent) transparentObjects.push(t);
        	else renderObjects.push(t);
        }
	}

	var lastBuffer, lastShader, shaderChanged, bufferChanged;

	var defOpts = {};

	r.render = function(root, camera, options) {
		var gl = SQR.gl;

		options = options || defOpts;

		if(!options.dontClear) context.clear();

		gl.disable(gl.BLEND);
		gl.enable(gl.DEPTH_TEST);
		gl.enable(gl.CULL_FACE);
        gl.frontFace(gl.CW);

		renderObjects.length = 0;
		transparentObjects.length = 0;
		
		updateTransform(root);

		if(camera) {
			camera.computeInverseMatrix();
		}

		renderObjects = renderObjects.concat(transparentObjects);

		var objectsToRender = renderObjects.length, ro, 
			lastBuffer = null, 
			lastShader = null,
			transparentRendering = false;
		

		var hasReplacementShader = options && options.replacementShader;

		if(hasReplacementShader) {
			lastShader = options.replacementShader.use();
		}

		for(var i = 0; i < objectsToRender; i++) {

			shaderChanged = false, bufferChanged = false;

			var ro = renderObjects[i];

			ro.transformView(camera ? camera.inverseWorldMatrix : null);

			if(ro.transparent) {

				if(!transparentRendering) {
					gl.enable(gl.BLEND);
					transparentRendering = true;
				}
				
				gl.blendFunc(ro.srcFactor, ro.dstFactor);
			}

			if(lastBuffer != ro.buffer) {
				lastBuffer = ro.buffer;
				lastBuffer.bind();
				bufferChanged = true;
			}

			if((lastShader != ro.shader) && !hasReplacementShader) {
				lastShader = ro.shader.use().updateTextures();
				var p = (camera && camera.projection) || r.projection;
				if(p) lastShader.setUniform('uProjection', p);
				shaderChanged = true;
			}

			if(shaderChanged || bufferChanged) {
				lastShader.attribPointers(lastBuffer);
			}

			ro.draw(options);
		}

	}

	r.renderToScreen = function() {
		var gl = SQR.gl;
		gl.bindFramebuffer(gl.FRAMEBUFFER, null);
	}

	return r;

}

/* --- --- [common/Shader.js] --- --- */

/**
 *	@class Shader
 *	@memberof SQR
 *
 *	@description Represents a GLSL shader. The shader class takes the source GLSL code,
 *	compiles it and extracts all the attributes and uniforms. It also exposes
 *	methods to set the uniform values of this shader.
 *
 *	Please read the {@tutorial basic-setup} tutorial to see how to use a shader  
 *	and the {@tutorial understanding-shaders} tutorial for an in depth discussion on shaders.
 *
 *
 *	@param {string} source - the GLSL source code formatted 
 *	in a way to include both vertex and fragment shaders.
 *
 *	@param {object} options - additional options, not required. Supported options in the code sample below.
 *
 *	@example
{
	// Do not compile 
	// (most of the time this is not necessary)
	doNotCompile: true,

	// Preprocesor directives. 
	// This object will create 
	// the following directives, attached to both
	// vertex and fragment shaders:
	// #define COLOR_ONLY
	// #define COLOR 1.0 0.0 0.0
	directives: [
	    { name: 'COLOR_ONLY' },
	    { name: 'COLOR', value: '1.0, 0.0, 0.0' }
	]
}
 */
SQR.Shader = function(source, options) {

	var s = {}, program, gl;
	var attributes = {}, attrList = [];
	var uniforms = {}, uniformList = [], uniformTextures = [];

	var parseGLSL = function(s) {

		if(!s) throw "> SQR.Shader.parseGLSL - Shader source code missing";

		var pp = "", pv = options ? options.directives : null;

		if(pv && pv instanceof Array) {
			for(var i = 0; i < pv.length; i++) {
				pp += "#define " + pv[i].name;
				if(pv[i].value) pp += " " + pv[i].value;
				pp += "\n";
			}
		} 

		var vertex = pp, fragment = pp;
		var isVertex = true;

		var ls = s.split("\n");

		for(var i = 0; i < ls.length; i++) {
			var l = ls[i];

			if (l.indexOf("//#include") > -1) {
				var p = l.substring(11), inc;

				if(SQR.GLSL && SQR.GLSL[p.substring(1)]) {
					inc = SQR.GLSL[p.substring(1)];
				} else {
					inc = SQR.Loader.assets[p.replace('~', SQR.shaderPath)];
				}

				if(!inc) throw "> SQR.Shader.parseGLSL - Include not found " + p;
				ls[i] = inc;
			}
		}

		var ls = ls.join('\n').split('\n');

		for(var i = 0; i < ls.length; i++) {
			var l = ls[i];
			if(l.indexOf("//#") > -1) {
				if (l.indexOf("//#fragment") > -1) {
					isVertex = false;
				} else if (l.indexOf("//#vertex") > -1) {
					isVertex = true;
				}  
			} else {
				if(l.indexOf("//") > -1) l = l.substring(0, l.indexOf("//"));

				if(l.match(/^([\s\t]*)$/)) continue;

				if(isVertex) {
					vertex += l + "\n";
				} else {
					fragment += l + "\n";
				}
			}
		}

		return { vertex: vertex, fragment: fragment };
	};

	s.compile = function() {
		var sc = source = parseGLSL(source);
		var gl = SQR.gl;
		var vs = gl.createShader(gl.VERTEX_SHADER);
        gl.shaderSource(vs, sc.vertex);
        gl.compileShader(vs);
         
        var fs = gl.createShader(gl.FRAGMENT_SHADER);
        gl.shaderSource(fs, sc.fragment);
        gl.compileShader(fs);
         
        program = gl.createProgram();
        gl.attachShader(program, vs);
        gl.attachShader(program, fs);
        gl.linkProgram(program);

        if(!gl.getShaderParameter(vs, gl.COMPILE_STATUS)) 
        	throw "> SQR.Shader. Vertex shader compile error: " + gl.getShaderInfoLog(vs);

        if(!gl.getShaderParameter(fs, gl.COMPILE_STATUS)) 
        	throw "> SQR.Shader. Fragment shader compile error: " + gl.getShaderInfoLog(fs);

        if(!gl.getProgramParameter(program, gl.LINK_STATUS)) 
        	throw "> SQR.Shader. Shader linking error: " + gl.getProgramInfoLog(program);

        return s;
	}

	s.inspect = function() {
		var gl = SQR.gl;
	    var numAttr = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);

	    for (var i = 0; i < numAttr; i++) {
	        var a = gl.getActiveAttrib(program, i);
	        a.location = gl.getAttribLocation(program, a.name);
	        attributes[a.name] = a;
	        attrList.push(a);
	    }

	    var numUni = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS), id = 0;

	    for (var i = 0; i < numUni; i++) {
	        var u = gl.getActiveUniform(program, i);
	        u.location = gl.getUniformLocation(program, u.name);

	        if(u.type == gl.SAMPLER_2D || u.type == gl.SAMPLER_CUBE) {
	        	u.texId = id++;
	        	uniformTextures.push(u);
	        }

	        uniforms[u.name] = u;
	        uniformList.push(u);
	    }

	    return s;
	}

	var stringType = 'string';

	s.getUniform = function(name) {
		return uniforms[name];
	}

	s.hasUniform = function(name) {
		return uniforms[name] != null;
	}

	s.setUniform = function(uniform, value) {
		var gl = SQR.gl;
		var n = (typeof uniform == stringType) ? uniforms[uniform] : uniform;
		var v = value;

		if(!n) {
			if(SQR.WARN_UNIFORM_NOT_PRESENT) {
				console.warn("> SQR.Shader attempt to set uniform that does not exist: " + uniform);
				console.trace();
			}
			return s;
		}

		if(v.toUniform) v = v.toUniform(n.type);

		switch (n.type) {
			case gl.BYTE:
				gl.uniform1i(n.location, v);
				break;
			case gl.UNSIGNED_BYTE:
				gl.uniform1i(n.location, v);
				break;
			case gl.SHORT:
				gl.uniform1i(n.location, v);
				break;
			case gl.UNSIGNED_SHORT:
				gl.uniform1i(n.location, v);
				break;
			case gl.INT:
				gl.uniform1i(n.location, v);
				break;
			case gl.INT_VEC2:
				gl.uniform2iv(n.location, v);
				break;
			case gl.INT_VEC3:
				gl.uniform3iv(n.location, v);
				break;
			case gl.INT_VEC4:
				gl.uniform4iv(n.location, v);
				break;
			case gl.UNSIGNED_INT:
				gl.uniform1i(n.location, v);
				break;
			case gl.FLOAT:
				gl.uniform1f(n.location, v);
				break;
			case gl.FLOAT_VEC2:
				gl.uniform2fv(n.location, v);
				break;
			case gl.FLOAT_VEC3:
				gl.uniform3fv(n.location, v);
				break;
			case gl.FLOAT_VEC4:
				gl.uniform4fv(n.location, v);
				break;
			case gl.BOOL:
				gl.uniform1i(n.location, v);
				break;
			case gl.BOOL_VEC2:
				gl.uniform2iv(n.location, v);
				break;
			case gl.BOOL_VEC3:
				gl.uniform3iv(n.location, v);
				break;
			case gl.BOOL_VEC4:
				gl.uniform4iv(n.location, v);
				break;
			case gl.FLOAT_MAT2:
				gl.uniformMatrix2fv(n.location, false, v.data || v);
				break;
			case gl.FLOAT_MAT3:
				gl.uniformMatrix3fv(n.location, false, v.data || v);
				break;
			case gl.FLOAT_MAT4:
				gl.uniformMatrix4fv(n.location, false, v.data || v);
				break;
			case gl.SAMPLER_2D:
				setTexture(n, v);
				break;
			case gl.SAMPLER_CUBE:
				setTextureCube(n, v);
				break;
			default:
				console.warn("> SQR.Shader > WARNING! Unknown uniform type ( 0x" + n.type.toString(16) + " )");
				break;
		}

		return s;
	}

	var setTexture = function(uniform, texture) {
		var gl = SQR.gl, id = uniform.texId;
		uniform.texref = texture;
	    gl.activeTexture(gl.TEXTURE0 + id); // 33984
		gl.bindTexture(gl.TEXTURE_2D, texture.tex || texture);
		if(texture.isAnimated) texture.update();
		gl.uniform1i(uniform.location, id);
	}

	var setTextureCube = function(uniform, texture) {
		var gl = SQR.gl, id = uniform.texId;
		uniform.texref = texture;
	    gl.activeTexture(gl.TEXTURE0 + id);
		gl.bindTexture(gl.TEXTURE_CUBE_MAP, texture.tex || texture);
		gl.uniform1i(uniform.location, id);
	}

	s.updateTextures = function() {
		var gl = SQR.gl;
		for(var i = 0, tl = uniformTextures.length; i < tl; i++) {
			var t = uniformTextures[i];
			if(t.texref) s.setUniform(t, t.texref);
		}
		return s;
	}

	s.use = function() {
		SQR.gl.useProgram(program);
		return s;
	}

	s.attribPointers = function(geo) {
		var gl = SQR.gl, al = attrList.length;
		geo = geo.buffer || geo;
		for(var i = 0; i < al; i++) {
			var a = attrList[i];
		 	var ga = geo.attributes[a.name];
		 	if(!ga) throw "> SQR.Shader expects attribute " + a.name + " but geometry doesn't provide it";
		 	if(!a.enabled) gl.enableVertexAttribArray(a.location);
			gl.vertexAttribPointer(a.location, ga.size, gl.FLOAT, false, geo.strideByteSize, ga.byteOffset);
			a.enabled = true;
		}
		return s;
	}


	if(!options || !options.doNotCompile) {
		s.compile();
		s.inspect();
	}

	return s;

}

/* --- --- [common/Texture.js] --- --- */

/**
 *  @class Texture
 *  @memberof SQR
 *
 *  @description Represents a WebGL texture created from an Image, Video or Canvas element.
 */
SQR.Texture = function(s, options) {

    options = options || {};

    if(!(s instanceof HTMLVideoElement || s instanceof Image || s instanceof HTMLCanvasElement)) {
        console.error('Invalid source: ' + s);
        throw 'SQR.Texture > provided source is not a valid source for texture';
    }

	var t = {};
	var gl = SQR.gl;
	var source = s;
	var texture = gl.createTexture();

	t.isAnimated = (options && options.isAnimated) || (s instanceof HTMLVideoElement);

	var isPowerOfTwo = function() {
        var x = source.width, y = source.height;
        return x > 0 && y > 0 && (x & (x - 1)) == 0 && (y & (y - 1)) == 0;
    }

	t.update = function() {
		var gl = SQR.gl;
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, source);
        return t;
	}

    var wrapS = options.wrapS || options.wrap || gl.CLAMP_TO_EDGE;
    var wrapT = options.wrapT || options.wrap || gl.CLAMP_TO_EDGE;

    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, source);

    var mif, mgf;

    if(isPowerOfTwo()) {
        gl.generateMipmap(gl.TEXTURE_2D);
        mif = gl.LINEAR_MIPMAP_LINEAR, mgf = gl.LINEAR;
    } else {
        mif = mgf = gl.LINEAR;
    }

    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, mgf);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, mif);

    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, wrapS);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, wrapT);
    gl.bindTexture(gl.TEXTURE_2D, null);

    t.tex = texture;

	return t;

}

/* --- --- [common/Transform.js] --- --- */

/**
 *  @class Transform
 *  @memberof SQR
 *
 *  @description A transform is a basic building block for 3D scenes made with squareroot.js
 * 
 *  @param name {string} the name of the transform.
 */
SQR.Transform = function(name) {

	var t = {};

	var inverseWorldMatrix;
    var transformState = 0;

    /**
     *  @var {string} name - a unique name of this transform, useful for debugging
     *  @memberof SQR.Transform.prototype
     *  @default `sqr.transform.` + a counter (ex. `sqr.transform.29)
     */
    t.name = name || 'sqr.transform.' + SQR.TransformCount++;

    /** 
     *  @var {boolean} active - is set to false, the transform and 
     *  all it's children will not be rendered.
     *  @memberof SQR.Transform.prototype
     *  @default false
     */
    t.active = true;

    /**
     *  @var {boolean} directMatrixMode - if set to true, position, rotation/quaternion and scale will be ignored
     *  @memberof SQR.Transform.prototype
     *
     *  @description When set to true matrix value inside @this.matrix can be manipulated directly.
     *
     *  @default false
     */
    t.directMatrixMode = false;
    

    /** 
     *  @var {SQR.Matrix44} matrix - object-to-parent transformation matrix
     *  @memberof SQR.Transform.prototype
     */
    t.matrix = new SQR.Matrix44();
    
    /** 
     *  @var {SQR.V3} position - the position of this transform relative to it's parent
     *  @memberof SQR.Transform.prototype
     */
	t.position = new SQR.V3();

    /** 
     *  @readonly 
     *  @var {SQR.V3} globalPosition - the global position of this transform (set automatically)
     *  @memberof SQR.Transform.prototype
     */
    t.globalPosition = new SQR.V3();

    /**
     *  @var {SQR.Quaternion} quaternion - A Quaternion that describes the rotation of the transform, 
     *  only active if `useQuaternion` is set to true.
     *  @memberof SQR.Transform.prototype
     */
	t.quaternion = new SQR.Quaternion();

    /**
     *  @var {SQR.V3} rotation - A 3D vector the describes the rotation of the transform in Euler angles, 
     *  disabled if `useQuaternion` is set to true.
     *  @memberof SQR.Transform.prototype
     */
	t.rotation = new SQR.V3();

    /**
     *  @var {SQR.V3} scale - the scale of the object on x, y and z axis
     *  @memberof SQR.Transform.prototype
     */
	t.scale = new SQR.V3(1, 1, 1);

    /**
     *  @var {SQR.Quaternion} useQuaternion - if set to true, 
     *  will use `quaternion` for rotation instead of the Euler angles in `rotation`
     *  @memberof SQR.Transform.prototype
     *  @default false
     */
	t.useQuaternion = false;

    /**
     *  @var {boolean} isStatic
     *  @description Any object can have two different positioning modes: dynamic or static.
     *  If this value is set to false (dynamic) the matrices 
     *  for this object will be recalculated at each frame.<br>
     *  If this value is set to true (static) the matrices for 
     *  this object will be recalculated only once.
     *  @memberof SQR.Transform.prototype
     *  @default false
     */
    t.isStatic = false;

    
	t.normalMatrix = new SQR.Matrix33();
	t.globalMatrix = new SQR.Matrix44();
    t.viewMatrix = new SQR.Matrix44();
    t.inverseWorldMatrix;

    t.lookAt = null;

    t.transparent = false;
    t.srcFactor = null;
    t.dstFactor = null;

    t.setBlending = function(transparent, src, dst) {
        t.transparent = transparent;
        // By default blend the object on top with the object on the bottom
        t.srcFactor = src || SQR.gl.SRC_ALPHA;
        t.dstFactor = dst || SQR.gl.ONE_MINUS_SRC_ALPHA;
    } 

	t.children = [], t.numChildren = 0;

   /**
    *   @method add
    *   @memberof SQR.Transform.prototype
    *   
    *   @description Add a child transform. Accepts multiple arguments but all of them need to be of type {SQR.Transform}.
    *   It doesn't do any sort of type checking so if you add non object that are not {SQR.Transform} 
    *   it will result in errors when the scene is rendered.
    */
    t.add = function() {
        for (var i = 0; i < arguments.length; i++) {
            var c = arguments[i];
            c.parent = t;
            if (t.children.indexOf(c) == -1) t.children.push(c);
        }
        t.numChildren = t.children.length;
        return t;
    }

    /**
     *  @method remove
     *  @memberof SQR.Transform.prototype
     *   
     *  @description Removes a child transform. Accepts multiple arguments 
     *  but all of them need to be of type {SQR.Transform}
     */
    t.remove = function() {
        for (var i = 0; i < arguments.length; i++) {
            var c = arguments[i];
            var j = t.children.indexOf(c);
            if (j == -1) return false;
            c.parent = null;
            t.children.splice(j, 1);
        }
        t.numChildren = t.children.length;
        return t;
    }
    
    /**
     *  @method removeAll
     *  @memberof SQR.Transform.prototype
     *   
     *  @description Removes all children transform.
     */
    t.removeAll = function() {
        t.children.length = 0;
        t.numChildren = 0;
    }

    /**
     *  @method contains
     *  @memberof SQR.Transform.prototype
     *   
     *  @description Checks if transform is child of this transfom
     *  @param {SQR.Transform} c the transform to look for
     */
    t.contains = function(c) {
        return t.children.indexOf(c) > -1;
    }

    /**
     *  @method recurse
     *  @memberof SQR.Transform.prototype
     *   
     *  @description Execute this function on all the child transforms including this current one.
     *
     *  @param {function} f the function that will be called on each child. 
     *  This function will receive the transform as argument.
     *
     *  @param {boolean} excludeSelf if set to true, the function will only be called for all 
     *  the ancestors of the Transform.
     */
    t.recurse = function(f, excludeSelf) {
       if(!excludeSelf) f(t);
        for (var i = 0; i < t.numChildren; i++) {
            t.children[i].recurse(f);
        }
    }

    t.draw = function(options) {
        var isReplacementShader = options && options.replacementShader;
        var shader = isReplacementShader ? options.replacementShader : t.shader;

        shader.setUniform('uMatrix', t.globalMatrix);
        shader.setUniform('uViewMatrix', t.viewMatrix);
        shader.setUniform('uNormalMatrix', t.normalMatrix);

        if(!isReplacementShader && shader.uniforms) {
            var un = Object.keys(shader.uniforms);
            for(var i = 0, l = un.length; i < l; i++) {
                shader.setUniform(un[i], shader.uniforms[un[i]]);
            }
        }

        if(!isReplacementShader && t.uniforms) {
            var un = Object.keys(t.uniforms);
            for(var i = 0, l = un.length; i < l; i++) {
                shader.setUniform(un[i], t.uniforms[un[i]]);
            }
        }

    	t.buffer.draw();
    }

	/**
     * Sets up the local matrix and multiplies is by the parents globalMatrix.
     * This function is called in the rendering process, do not call directly.
     *
     */
    t.transformWorld = function() {

        if(transformState == 1) return;

        if(!t.directMatrixMode) {
        	var p = t.position;
            var s = t.scale;
            
            if (t.useQuaternion) {
                var q = t.quaternion;
            	t.matrix.setTQS(p.x, p.y, p.z, q.w, q.x, q.y, q.z, s.x, s.y, s.z);
           	} else {
                var r = t.rotation;
    			t.matrix.setTRS(p.x, p.y, p.z, r.x, r.y, r.z, s.x, s.y, s.z);
            }
        }

        if(t.lookAt) {
            t.matrix.lookAt(t.lookAt.position);
        }

        if (t.parent) {
            t.parent.globalMatrix.copyTo(t.globalMatrix);
            t.globalMatrix.multiply(t.matrix);
        } else {
            t.matrix.copyTo(t.globalMatrix);
        }

        t.globalMatrix.extractPosition(t.globalPosition);

        if(t.isStatic) transformState = 1;
    }

    /** 
     *  Used for sorting object in the rendering function
     *  (not implemented yet)
     */
    t.viewDepth = function() {
        return t.viewMatrix.data[14];
    }

    /**
     * Calculate the view matrix.
     *
     * This function is called in the rendering process, do not call directly.
     *
     * @param inverseCamMatrix {SQR.Matrix44} the inverse matrix of the camera
     */
    t.transformView = function(inverseCamMatrix) {
        if(inverseCamMatrix) {
            inverseCamMatrix.copyTo(t.viewMatrix);
            t.viewMatrix.multiply(t.globalMatrix);
            t.viewMatrix.inverseMat3(t.normalMatrix);
        } else {
            t.globalMatrix.copyTo(t.viewMatrix);
            t.viewMatrix.inverseMat3(t.normalMatrix);
        }
        
    }

	/**
     * Calculate the camera inverse matrix.
     *
     * Used only if this transform is a camera.
     *
     * This function is called in the rendering process, do not call directly.
     */
    t.computeInverseMatrix = function() {
    	if(!t.inverseWorldMatrix) {
            t.inverseWorldMatrix = new SQR.Matrix44();
        }
        t.globalMatrix.inverse(t.inverseWorldMatrix);
        return t.inverseWorldMatrix;
    }

	return t;

}

SQR.TransformCount = 0;








/* --- --- [math/Bezier.js] --- --- */

/**
 *  @class Bezier
 *  @memberof SQR
 *
 *  @description Represents a cubic bezier curve. All paramaters can be either {@link SQR.V3} or {@link SQR.V2}.
 *
 *  @param _p0 start position
 *  @param _c0 first control point
 *  @param _c1 last control point
 *  @param _c1 end position
 *
 */
SQR.Bezier = function(_p0, _c0, _c1, _p1) {

    var that = this;

    /**
     *  @var p0 
     *  @memberof SQR.Bezier.prototype
     *  @descripton The start position, can be either {@link SQR.V3} or {@link SQR.V2}.
     */
    this.p0 = _p0;

    /**
     *  @var c0 
     *  @memberof SQR.Bezier.prototype
     *  @descripton First control point. Can be either {@link SQR.V3} or {@link SQR.V2}.
     */
    this.c0 = _c0;

    /**
     *  @var c1 
     *  @memberof SQR.Bezier.prototype
     *  @descripton Second control point. Can be either {@link SQR.V3} or {@link SQR.V2}.
     */
    this.c1 = _c1;

    /**
     *  @var p1 
     *  @memberof SQR.Bezier.prototype
     *  @descripton End position. Can be either {@link SQR.V3} or {@link SQR.V2}.
     */
    this.p1 = _p1;

    var interpolatedValue, interpolatedVelocity, interpolatedMatrix;

    var pfunc = SQR.Interpolation.bezierPosition;
    var vfunc = SQR.Interpolation.bezierVelocity;

    /**
     *  @method velocityAt 
     *  @memberof SQR.Bezier.prototype
     *  @description Returns the velocity on a curve. 
     *  @param t interpolation value [0-1]
     *  @param v vector to write the value to. If omitted, returns a temporary value, that will be overwritten on next call so do not store this object.
     */
    this.velocityAt = function(t, v) {
        interpolatedVelocity = interpolatedVelocity || this.p0.clone().set();
        v = v || interpolatedVelocity;
        v.x = vfunc(t, this.p0.x, this.c0.x, this.c1.x, this.p1.x);
        v.y = vfunc(t, this.p0.y, this.c0.y, this.c1.y, this.p1.y);

        if(v.z !== null && this.p0.z !== null) {
            v.z = vfunc(t, this.p0.z, this.c0.z, this.c1.z, this.p1.z);
        }

        return v;
    }

    /**
     *  @method valueAt 
     *  @memberof SQR.Bezier.prototype
     *  @description Returns the position on a curve.
     *  @param t interpolation value [0-1]
     *  @param v vector to write the value to. If omitted, returns a temporary value, that will be overwritten on next call so do not store this object.
     */
    this.valueAt = function(t, v) {
        interpolatedValue = interpolatedValue || this.p0.clone().set();
        v = v || interpolatedValue;
        v.x = pfunc(t, this.p0.x, this.c0.x, this.c1.x, this.p1.x);
        v.y = pfunc(t, this.p0.y, this.c0.y, this.c1.y, this.p1.y);

        if(v.z !== null && this.p0.z !== null) {
            v.z = pfunc(t, this.p0.z, this.c0.z, this.c1.z, this.p1.z);
        }
        
        return v;
    }

    /** 
     *  @method matrixAt 
     *  @memberof SQR.Bezier.prototype
     *  @description Returns the transformation matrix that can be used to align an object to the curve at a given point.
     *  Not tested in 2D but shoud work fine.
     *  @param t interpolation value [0-1]
     *  @param m {@link SQR.Matrix44} to write the matrix to. If omitted, returns a temporary value, that will be overwritten on next call so do not store this object.
     */
    this.matrixAt = function(t, m) {
        interpolatedMatrix = interpolatedMatrix || new SQR.Matrix44();
        m = m || interpolatedMatrix;
        m.identity();

        var va = that.valueAt(t);
        var vc = that.velocityAt(t).norm();
        var vl = SQR.V3.__tv1.set().cross(vc, SQR.V3.up);//.norm();
        var vn = SQR.V3.__tv2.set().cross(vc, vl);//.norm()

        m.data[0] = vl.x, m.data[4] = vn.x, m.data[8] = vc.x;
        m.data[1] = vl.y, m.data[5] = vn.y, m.data[9] = vc.y;
        m.data[2] = vl.z, m.data[6] = vn.z, m.data[10] = vc.z;
        m.setTranslation(va.x, va.y, va.z);

        return m;
    }
}













/* --- --- [math/ConvexHull.js] --- --- */

/**
 *  @class ConvexHull
 *  @memberof SQR
 *
 *  @description utility to compute a convex hull. Based on algorithm from Chapter 1 in 
 *	{@link http://www.amazon.com/dp/3540779736/?tag=stackoverfl08-20} and code from 
 *	{@link http://blog.cedric.ws/draw-the-convex-hull-with-canvas-and-javascript} 
 *	which is basically the implementation of the algorithm explained in the book.
 *
 *	Other links: 
 *
 *	{@link http://www.travellermap.com/tmp/delaunay.js}
 *	{@link https://github.com/ironwallaby/delaunay/blob/master/delaunay.js}
 *	{@link http://paulbourke.net/papers/triangulate/}
 */
SQR.ConvexHull = (function() {



	var upper = [], lower = [], hull = [];

	var sortXY = function(a, b) {
		if(a.x == b.x) return a.y - b.y;
		else return a.x - b.x;
	}

	var isRight = function(a, b, c){
		return ( 
			(c.x * a.y - c.y * a.x) - 
			(b.x * a.y - b.y * a.x) + 
			(b.x * c.y - b.y * c.x)) < 0;
	}

	var upperHull = function(p, u) {

		u.push(p[0]);
		u.push(p[1]);

		for(var i = 2, l = p.length; i < l; i++) {

			u.push(p[i]);

			while(u.length > 2 &&
				!isRight(
					u[u.length-3],
					u[u.length-1],
					u[u.length-2]
				)
			) {
				u.splice(
					u.indexOf(u[u.length-2]), 
					1
				);
			}
		}

		return u;
	}

	var lowerhull = function(p, u){

		u.push(p[p.length-1]);
		u.push(p[p.length-2]);

		for(var i = p.length-3; i >= 0; i--) {
			u.push(p[i]);

			while(u.length > 2 &&
				!isRight(
					u[u.length-3], 
					u[u.length-1],
					u[u.length-2]
				)
			) {
				u.splice(
					u.indexOf(u[u.length-2]), 
					1
				);
			}
		}

		return u;
	}

	return {
		/** 
		 *	@method compute
		 *	@memberof SQR.ConvexHull
		 *
		 *	@desription computes the convexhull for a give set of points
		 *	
		 *	@param {Array} p - array of {@link SQR.V2} or any objects that have a `x` and `y` property.
		 *	@param {Array} h - the array to store the result in. If omitted, new one is created.
		 *
		 *	@returns {Array} array of {@link SQR.V2} containing ordered points that make the convexhull.
		 */
		compute: function(p, h) {

			if(!h) h = hull;

			upper.length = 0, lower.length = 0, h.length = 0;

			p.sort(sortXY);

			upperHull(p, upper);
			lowerhull(p, lower);

			h = h.concat(upper, lower);

			return h;
		}
	}

})();











/* --- --- [math/Delaunay.js] --- --- */

/**
 *  
 *	@class Delaunay
 *  @memberof SQR
 *
 *  @description based on:<br> 
 *  
 *  {@link http://paulbourke.net/papers/triangulate/}<br>
 *  {@link http://www.travellermap.com/tmp/delaunay.htm} (original code)<br> 
 *  {@link https://github.com/ironwallaby/delaunay/blob/master/delaunay.js}<br> 
 *  {@link http://www.amazon.com/Computational-Geometry-Applications-Mark-Berg/dp/3642096816}
*/
SQR.Delaunay = (function() {

	var delaunay = {};

	var Edge = function(v0, v1) {
		this.v0 = v0;
		this.v1 = v1;
	}

	Edge.prototype.equals = function(other) {
		return (this.v0 === other.v0 && this.v1 === other.v1);
	};

	Edge.prototype.inverse = function() {
		return new Edge(this.v1, this.v0);
	};

	var createSuperTriangle = function(vertices) {
		// NOTE: There's a bit of a heuristic here. If the bounding triangle 
		// is too large and you see overflow/underflow errors. If it is too small 
		// you end up with a non-convex hull.

		var minx, miny, maxx, maxy;
		vertices.forEach(function(vertex) {
			if (minx === undefined || vertex.x < minx) { minx = vertex.x; }
			if (miny === undefined || vertex.y < miny) { miny = vertex.y; }
			if (maxx === undefined || vertex.x > maxx) { maxx = vertex.x; }
			if (maxy === undefined || vertex.y > maxy) { maxy = vertex.y; }
		});

		var dx = (maxx - minx) * 10;
		var dy = (maxy - miny) * 10;

		var stv0 = new SQR.V2(minx - dx, miny - dy * 3);
		var stv1 = new SQR.V2(minx - dx, maxy + dy);
		var stv2 = new SQR.V2(maxx + dx * 3, maxy + dy);

		return new SQR.Triangle(stv0, stv1, stv2);
	}

	function addVertex(vertex, triangles) {
		var edges = [];

		triangles = triangles.filter(function(triangle) {
			if (triangle.vertexInCircumcircle(vertex)) {
				edges.push(new Edge(triangle.v0, triangle.v1));
				edges.push(new Edge(triangle.v1, triangle.v2));
				edges.push(new Edge(triangle.v2, triangle.v0));
				return false;
			}

			return true;
		});

		edges = uniqueEdges(edges);

		edges.forEach(function(edge) {
			triangles.push(new SQR.Triangle(edge.v0, edge.v1, vertex));
		});

		return triangles;
	}

	var uniqueEdges = function(edges) {
		var uniqueEdges = [];

		for (var i = 0; i < edges.length; ++i) {
			var edge1 = edges[i];
			var unique = true;

			for (var j = 0; j < edges.length; ++j) {
				if (i === j) continue;
				var edge2 = edges[j];
				if (edge1.equals(edge2) || edge1.inverse().equals(edge2)) {
					unique = false;
					break;
				}
			}

			if (unique) uniqueEdges.push(edge1);
		}

		return uniqueEdges;
	}

	/**
	 *	@method triangulate
	 *	@memberof SQR.Delaunay
	 *
	 *	@description Performs Delaunay triangulation.
	 *
	 *	@param vertices - a list of 2d vertices. 
	 *	Can be {@link SQR.V2}, {@link SQR.V3} or any object that has `x` and `y` properties. 
	 *	In case of a 3d vector, the `z` component is ignored.
	 *	@returns a list of {@link SQR.Triangles}
	 */
	delaunay.triangulate = function(vertices) {
		var triangles = [];

		var st = createSuperTriangle(vertices);

		triangles.push(st);

		vertices.forEach(function(vertex) {
			// NOTE: This is O(n^2) - can be optimized by sorting vertices
			// along the x-axis and only considering triangles that have 
			// potentially overlapping circumcircles
			triangles = addVertex(vertex, triangles);
		});

		// Remove triangles that shared edges with "supertriangle"
		triangles = triangles.filter(function(triangle) {
			return !(triangle.v0 == st.v0 || triangle.v0 == st.v1 || triangle.v0 == st.v2 ||
			triangle.v1 == st.v0 || triangle.v1 == st.v1 || triangle.v1 == st.v2 ||
			triangle.v2 == st.v0 || triangle.v2 == st.v1 || triangle.v2 == st.v2);
		});

		return triangles;
	}

	return delaunay;

})();

/* --- --- [math/Interpolation.js] --- --- */

/**
 *  @class Interpolation
 *  @memberof SQR
 *
 *  @description A collection of interpolation functions.
 */
SQR.Interpolation = {

    /**
     *  Returns the position on a curve for a position (per axis)
     *  @param {Number} t interpolation value [0-1]
     *  @param {Number} p0 start position
     *  @param {Number} c0 first control point
     *  @param {Number} c1 second control point
     *  @param {Number} p1 end position
     */
    bezierPosition: function(t, p0, c0, c1, p1) {
        return p0 * (1 - t) * (1 - t) * (1 - t) +
            c0 * 3 * t * (1 - t) * (1 - t) +
            c1 * 3 * t * t * (1 - t) +
            p1 * t * t * t;
    },

    /**
     *  Returns the velocity on the curve for a position (per axis)
     *  @param {Number} t interpolation value [0-1]
     *  @param {Number} p0 start position
     *  @param {Number} c0 first control point
     *  @param {Number} c1 second control point
     *  @param {Number} p1 end position
     */
    bezierVelocity: function(t, p0, c0, c1, p1) {
        return (3 * c0 - 3 * p0)
            + 2 * (3 * p0 - 6 * c0 + 3 * c1) * t
            + 3 * (-p0 + 3 * c0 - 3 * c1 + p1) * t * t;
    },

    /**
     *  Linear interpolation a between two values
     *  @param {Number} e0 start value
     *  @param {Number} e1 end value
     *  @param {Number} t interpolation value [0-1]
     */
    linear: function(e0, e1, t) {
        if(t <= e0) return e0;
        if(t >= e1) return e1;

        t = (t - e0) / (e1 - e0);

        return e0 + (e1 - e0) * t;
    },
    
    /**
     *  Smoothstep interpolation a between two values
     *  @param {Number} t interpolation value [0-1]
     */
    smoothStep: function(t) {
        return (3 * t * t - 2 * t * t * t);
    },

    /**
     *  Quadratic ease in based on Penner equations
     *  @param {Number} t interpolation value [0-1]
     */
    quadIn: function (t) {
        return t * t;
    },

    /**
     *  Quadratic ease out based on Penner equations
     *  @param {Number} t interpolation value [0-1]
     */
    quadOut: function (t) {
        return t * (2 - t);
    },

    /**
     *  Quadratic ease in-out based on Penner equations
     *  @param {Number} t interpolation value [0-1]
     */
    quadInOut: function (t) {
        if (( t *= 2 ) < 1)
            return 0.5 * t * t;
        else
            return -0.5 * ( --t * ( t - 2 ) - 1 );
    }

};

/* --- --- [math/Matrix2D.js] --- --- */

/**
 *  @class Matrix2D
 *  @memberof SQR
 *
 *  @description A matrix that implements 2D affine transformations. 
 *  Most of the method return the current instance for chaining.
 *
 *  @todo Make it column major
 */
SQR.Matrix2D = function() {

    this.data = new Float32Array(9);

    var a, b, d, x, y;

    /**
     *  @method identity
     *  @memberof SQR.Matrix2D.prototype
     *  @description Resets the matrix to identity values.
     */
    this.identity = function(d) {
        d = d || this.data;
        d[0] = 1,d[3] = 0,d[6] = 0;
        d[1] = 0,d[4] = 1,d[7] = 0;
        d[2] = 0,d[5] = 0,d[8] = 1;

        return this;
    }

    /**
     *  @method transformVector
     *  @memberof SQR.Matrix2D.prototype
     *  @description Multiplies the vector by the matrix
     *  @param v vector to multiply
     *  @returns the same vector as passed in the parameter, multiplied by this matrix
     */
    this.transformVector = function(v) {
        d = this.data;
        x = v.x,y = v.y;
        v.x = d[0] * x + d[1] * y + d[2];
        v.y = d[3] * x + d[4] * y + d[5];
        return v;
    }

    /**
     *  @method setTranslation
     *  @memberof SQR.Matrix2D.prototype
     *  @description Sets the translation values.
     *  @param tx x translation
     *  @param ty y translation
     *  @param m the matrix to set translation to, applies to this if ommited
     */
    this.setTranslation = function(tx, ty, m) {
        d = m || this.data;
        d[0] = 1,d[3] = 0,d[6] = tx;
        d[1] = 0,d[4] = 1,d[7] = ty;
        d[2] = 0,d[5] = 0,d[8] = 1;
        return this;
    }

    /**
     *  @method getTranslation
     *  @memberof SQR.Matrix2D.prototype
     *  @description Returns the translation value as 2d vector.
     *  @param {SQR.V2} v vector to use to return values in, if ommited a new vector object is returned
     *  @returns {SQR.V2} 2d vector with translation values
     */
    this.getTranslation = function(v) {
        d = this.data;
        v = v || new SQR.V2();
        v.x = d[2];
        v.y = d[5];
        return v;
    }

    /**
     *  @method setScale
     *  @memberof SQR.Matrix2D.prototype
     *  @description Sets the scale values.
     *  @param sx x scale
     *  @param sy y scale
     *  @param m the matrix to set scale to, applies to `this` if ommited
     */
    this.setScale = function(sx, sy, m) {
        d = m || this.data;
        d[0] = sx,d[3] = 0, d[6] = 0;
        d[1] = 0, d[4] = sy,d[7] = 0;
        d[2] = 0, d[5] = 0, d[8] = 1;
        return this;
    }

    /**
     *  @method setShear
     *  @memberof SQR.Matrix2D.prototype
     *  @description Sets the scale values.
     *  @param sx x shear
     *  @param sy y shear
     *  @param m the matrix to set shear to, applies to `this` if ommited
     */
    this.setShear = function(sx, sy, m) {
        d = m || this.data;
        d[0] = 1, d[3] = sx,d[6] = 0;
        d[1] = sy,d[4] = 1, d[7] = 0;
        d[2] = 0, d[5] = 0, d[8] = 1;
        return this;
    }

    /**
     *  @method setRotation
     *  @memberof SQR.Matrix2D.prototype
     *  @description Sets the rotation value.
     *  @param a angle in radians
     *  @param m the matrix to set shear to, applies to `this` if ommited
     */
    this.setRotation = function(a, m) {
        d = m || this.data;
        var r0 = Math.cos(a);
        var r1 = Math.sin(a);
        d[0] = r0,d[3] = -r1,d[6] = 0;
        d[1] = r1,d[4] = r0, d[7] = 0;
        d[2] = 0, d[5] = 0,  d[8] = 1;
        return this;
    }

    /**
     *  @method setTRS
     *  @memberof SQR.Matrix2D.prototype
     *  @description Sets the translation/rotation/scale values at once.
     *  @param tx x translation
     *  @param ty y translation
     *  @param a angle in radians
     *  @param sx x scale
     *  @param sy y scale
     */
    this.setTRS = function(tx, ty, a, sx, sy) {
        d = this.data;
        var r0 = Math.cos(a);
        var r1 = Math.sin(a);
        d[0] = r0 * sx,d[3] = -r1 * sy,d[6] = tx;
        d[1] = r1 * sx,d[4] = r0 * sy, d[7] = ty;
        d[2] = 0,      d[5] = 0,       d[8] = 1;
        return this;
    }

    /** 
     *  @method translate
     *  @memberof SQR.Matrix2D.prototype
     *  @description Applies translation to matrix
     *  @param tx x translation
     *  @param ty y translation
     */
    this.translate = function(tx, ty) {
        this.identity(SQR.Matrix2D.__temp);
        this.setTranslation(tx, ty, SQR.Matrix2D.__temp);
        return this.multiply(SQR.Matrix2D.__temp);
    }

    /** 
     *  @method rotate
     *  @memberof SQR.Matrix2D.prototype
     *  @param a angle in radians
     *  @description Applies rotation to matrix
     */
    this.rotate = function(a) {
        this.identity(SQR.Matrix2D.__temp);
        this.setRotation(a, SQR.Matrix2D.__temp);
        return this.multiply(SQR.Matrix2D.__temp);
    }

    /** 
     *  @method scale
     *  @memberof SQR.Matrix2D.prototype
     *  @param sx x scale
     *  @param sy y scale
     *  @description Applies scale to matrix
     */
    this.scale = function(sx, sy) {
        this.identity(SQR.Matrix2D.__temp);
        this.setScale(sx, sy, SQR.Matrix2D.__temp);
        return this.multiply(SQR.Matrix2D.__temp);
    }

    /** 
     *  @method shear
     *  @memberof SQR.Matrix2D.prototype
     *  @param sx x shear
     *  @param sy y shear
     *  @description Applies shear to matrix
     */
    this.shear = function(sx, sy) {
        this.identity(SQR.Matrix2D.__temp);
        this.setRotation(sx, sy, SQR.Matrix2D.__temp);
        return this.multiply(SQR.Matrix2D.__temp);
    }

    var a11, a12, a13, a21, a22, a23, a31, a32, a33;
    var b11, b12, b13, b21, b22, b23, b31, b32, b33;

    /** 
     *  @method multiply
     *  @memberof SQR.Matrix2D.prototype
     *  @param m matrix to multiply the current matrix by
     *  @description Multiples current matrix by m and stores result in current matrix.
     */
    this.multiply = function(m) {
        a = this.data, b = m.data || m;

        a11 = a[0],a12 = a[3],a13 = a[6];
        a21 = a[1],a22 = a[4],a23 = a[7];
        a31 = a[2],a32 = a[5],a33 = a[8];

        b11 = b[0],b12 = b[3],b13 = b[6];
        b21 = b[1],b22 = b[4],b23 = b[7];
        b31 = b[2],b32 = b[5],b33 = b[8];

        a[0] = a11 * b11 + a12 * b21 + a13 * b31;
        a[3] = a11 * b12 + a12 * b22 + a13 * b32;
        a[6] = a11 * b13 + a12 * b23 + a13 * b33;

        a[1] = a21 * b11 + a22 * b21 + a23 * b31;
        a[4] = a21 * b12 + a22 * b22 + a23 * b32;
        a[7] = a21 * b13 + a22 * b23 + a23 * b33;

        //a[6] = a31 * b11 + a32 * b21 + a33 * b31;
        //a[7] = a31 * b12 + a32 * b22 + a33 * b32;
        //a[8] = a31 * b13 + a32 * b23 + a33 * b33;

        return this;
    }

    /** 
     *  @method copyTo
     *  @memberof SQR.Matrix2D.prototype
     *  @param m matrix to copy values to. Can be {SQR.Matrix2D} or {Float32Array}
     *  @description Copies current matrix values to m
     */
    this.copyTo = function(m) {
        a = this.data,b = m.data || m;

        b[0] = a[0],b[1] = a[1],b[2] = a[2];
        b[3] = a[3],b[4] = a[4],b[5] = a[5];
        b[6] = a[6],b[7] = a[7],b[8] = a[8];

        return m;
    }

    /** 
     *  @method copyFrom
     *  @memberof SQR.Matrix2D.prototype
     *  @param m matrix to copy values from. Can be {SQR.Matrix2D} or {Float32Array}
     *  @description Copies values from m into the current matrix
     */
    this.copyFrom = function(m) {
        a = m.data || m,b = this.data;

        b[0] = a[0],b[1] = a[1],b[2] = a[2];
        b[3] = a[3],b[4] = a[4],b[5] = a[5];
        b[6] = a[6],b[7] = a[7],b[8] = a[8];

        return this;
    }

    this.identity();
}

SQR.Matrix2D.__temp = new Float32Array(9);
















/* --- --- [math/Matrix33.js] --- --- */

/**
 *  @class Matrix33
 *  @memberof SQR
 *
 *  @description A 3x3 matrix for used to hold rotations and normal matrices
 */
SQR.Matrix33 = function() {

    this.data = new Float32Array(9);

    this.identity = function() {
        var d = this.data;
        d[0] = 1,d[3] = 0,d[6] = 0;
        d[1] = 0,d[4] = 1,d[7] = 0;
        d[2] = 0,d[5] = 0,d[8] = 1;
        return this;
    }

    this.transformVector = function (v, pv) {
        var d = this.data;
        var x = v.x, y = v.y, z = v.z;
        pv = pv || v;

        pv.x = d[0] * x + d[3] * y + d[6] * z;
        pv.y = d[1] * x + d[4] * y + d[7] * z;
        pv.z = d[2] * x + d[5] * y + d[8] * z;

        return pv;
    }

    this.determinant = function() {
        var d = this.data;

        return d[0] * (d[4] * d[8] - d[7] * d[5]) +
               d[3] * (d[7] * d[2] - d[1] * d[8]) +
               d[6] * (d[1] * d[5] - d[4] * d[2]);
    }

    this.inverse = function(m) {
        var d = this.data;
        m = m || this.data;

        var a00 = d[0], a01 = d[1], a02 = d[2],
            a10 = d[3], a11 = d[4], a12 = d[5],
            a20 = d[6], a21 = d[7], a22 = d[8],

            b01 = a22 * a11 - a12 * a21,
            b11 = -a22 * a10 + a12 * a20,
            b21 = a21 * a10 - a11 * a20,

            d = a00 * b01 + a01 * b11 + a02 * b21,
            id;

        if (!d) {
            console.warn("Attempt to inverse a singular matrix33. ", this.data);
            return m;
        }
        
        id = 1 / d;

        m[0] = b01 * id;
        m[1] = (-a22 * a01 + a02 * a21) * id;
        m[2] = (a12 * a01 - a02 * a11) * id;
        m[3] = b11 * id;
        m[4] = (a22 * a00 - a02 * a20) * id;
        m[5] = (-a12 * a00 + a02 * a10) * id;
        m[6] = b21 * id;
        m[7] = (-a21 * a00 + a01 * a20) * id;
        m[8] = (a11 * a00 - a01 * a10) * id;

        return m;

    }

    this.transpose = function() {
        var d = this.data;

        var d0 = d[0], d3 = d[3], d6 = d[6],
            d1 = d[1], d4 = d[4], d7 = d[7],
            d2 = d[2], d5 = d[5], d8 = d[8];

        d[0] = d0;
        d[1] = d3;
        d[2] = d6;

        d[3] = d1;
        d[4] = d4;
        d[5] = d7;

        d[6] = d2;
        d[7] = d5;
        d[8] = d8;
    }

}

/* --- --- [math/Matrix44.js] --- --- */

/**
 *  @class Matrix44
 *  @memberof SQR
 *
 *  @description A multi-purpose 4x4 matrix.
 */
SQR.Matrix44 = function(data) {

    this.data = data || new Float32Array(16);

    this.identity = function(m) {
        var d = m || this.data;
        d[0] = 1,d[4] = 0,d[8] = 0,d[12] = 0;
        d[1] = 0,d[5] = 1,d[9] = 0,d[13] = 0;
        d[2] = 0,d[6] = 0,d[10] = 1,d[14] = 0;
        d[3] = 0,d[7] = 0,d[11] = 0,d[15] = 1;
        return this;
    }

    /**
     *  @memberof SQR.Matrix44.prototype
     *  @description Multiplies the vector v by my this matrix and stores the result in the vector pv.
     *
     *  @param {SQR.V3} v - the vector to be multiplies by this matrix
     *  @param {SQR.V3=} pv - the vector in which to store the result. If ommited, result is stored in v.
     */
    this.transformVector = function (v, pv) {
        var d = this.data;
        var x = v.x, y = v.y, z = v.z, w = v.w;
        pv = pv || v;
        
        pv.x = d[0] * x + d[4] * y + d[8] * z + d[12] * w;
        pv.y = d[1] * x + d[5] * y + d[9] * z + d[13] * w;
        pv.z = d[2] * x + d[6] * y + d[10] * z + d[14] * w;
        // pv.w = d[3] * x + d[7] * y + d[11] * z + d[15] * w;

        return pv;
    }

    /**
     *  @memberof SQR.Matrix44.prototype
     *  @description Multiplies this matrix by m
     *  @param {SQR.Matrix44} m - matrix to multiply this matrix by
     */
    this.multiply = function(m) {
        var a = this.data, b = m.data || m;

        var a00, a01, a02, a03, a04, a05, a06, a07, a08, a09, a10, a11, a12, a13, a14, a15;
        var b00, b01, b02, b03, b04, b05, b06, b07, b08, b09, b10, b11, b12, b13, b14, b15;

        a00 = a[0],a01 = a[1],a02 = a[2],a03 = a[3];
        a04 = a[4],a05 = a[5],a06 = a[6],a07 = a[7];
        a08 = a[8],a09 = a[9],a10 = a[10],a11 = a[11];
        a12 = a[12],a13 = a[13],a14 = a[14],a15 = a[15];

        b00 = b[0],b01 = b[1],b02 = b[2],b03 = b[3];
        b04 = b[4],b05 = b[5],b06 = b[6],b07 = b[7];
        b08 = b[8],b09 = b[9],b10 = b[10],b11 = b[11];
        b12 = b[12],b13 = b[13],b14 = b[14],b15 = b[15];

        a[0] = a00 * b00 + a04 * b01 + a08 * b02 + a12 * b03;
        a[1] = a01 * b00 + a05 * b01 + a09 * b02 + a13 * b03;
        a[2] = a02 * b00 + a06 * b01 + a10 * b02 + a14 * b03;
        a[3] = a03 * b00 + a07 * b01 + a11 * b02 + a15 * b03;

        a[4] = a00 * b04 + a04 * b05 + a08 * b06 + a12 * b07;
        a[5] = a01 * b04 + a05 * b05 + a09 * b06 + a13 * b07;
        a[6] = a02 * b04 + a06 * b05 + a10 * b06 + a14 * b07;
        a[7] = a03 * b04 + a07 * b05 + a11 * b06 + a15 * b07;

        a[8] = a00 * b08 + a04 * b09 + a08 * b10 + a12 * b11;
        a[9] = a01 * b08 + a05 * b09 + a09 * b10 + a13 * b11;
        a[10] = a02 * b08 + a06 * b09 + a10 * b10 + a14 * b11;
        a[11] = a03 * b08 + a07 * b09 + a11 * b10 + a15 * b11;

        a[12] = a00 * b12 + a04 * b13 + a08 * b14 + a12 * b15;
        a[13] = a01 * b12 + a05 * b13 + a09 * b14 + a13 * b15;
        a[14] = a02 * b12 + a06 * b13 + a10 * b14 + a14 * b15;
        a[15] = a03 * b12 + a07 * b13 + a11 * b14 + a15 * b15;

        return this;
    }

    /**
     *  @method setTQS
     *  @memberof SQR.Matrix44.prototype
     *  @description Sets the translation/rotation/scale values at once. 
     *  Similar to setTRS but the rotation is defined as a quaternion.
     *  @param tx x translation
     *  @param ty y translation
     *  @param tz y translation
     *  @param qw w compoment of the quaternion
     *  @param qx x compoment of the quaternion
     *  @param qx y compoment of the quaternion
     *  @param qx z compoment of the quaternion
     *  @param sx x scale
     *  @param sy y scale
     *  @param sz z scale
     *  @param m the matrix to set scale to, applies to `this` if ommited
     */
    this.setTQS = function(tx, ty, tz, qw, qx, qy, qz, sx, sy, sz, m) {

        var d = m || this.data;
        this.identity(m);

        var sqx = qx * qx;
        var sqy = qy * qy;
        var sqz = qz * qz;

        d[0] = (1 - 2 * sqy - 2 * sqz) * sx;
        d[1] = (2 * qx * qy - 2 * qz * qw) * sx;
        d[2] = (2 * qx * qz + 2 * qy * qw) * sx;

        d[4] = (2 * qx * qy + 2 * qz * qw) * sy;
        d[5] = (1 - 2 * sqx - 2 * sqz) * sy;
        d[6] = (2 * qy * qz - 2 * qx * qw) * sy;

        d[8] = (2 * qx * qz - 2 * qy * qw) * sz;
        d[9] = (2 * qy * qz + 2 * qx * qw) * sz;
        d[10] = (1 - 2 * sqx - 2 * sqy) * sz;

        d[12] = tx;
        d[13] = ty;
        d[14] = tz;

        return m || this;
    }

    /**
     *  @method setTRS
     *  @memberof SQR.Matrix44.prototype
     *  @description Sets the translation/rotation/scale values at once.
     *  @param tx x translation
     *  @param ty y translation
     *  @param tz y translation
     *  @param rx rotation angle in radians on the x axis
     *  @param ry rotation angle in radians on the y axis
     *  @param rz rotation angle in radians on the z axis
     *  @param sx x scale
     *  @param sy y scale
     *  @param sz z scale
     *  @param m the matrix to set scale to, applies to `this` if ommited
     */
    this.setTRS = function(tx, ty, tz, rx, ry, rz, sx, sy, sz, m) {

        var d = m || this.data;
        this.identity(m);

        var six = Math.sin(rx), cox = Math.cos(rx), siy = Math.sin(ry), coy = Math.cos(ry), siz = Math.sin(rz), coz = Math.cos(rz);

        // fliping this part changes from left handed to right handed (I think)
        d[0] = (coy * coz + siy * six * siz) * sx;
        d[1] = (-coy * siz + siy * six * coz) * sx;
        d[2] = siy * cox * sx;

        d[4] = siz * cox * sy;
        d[5] = coz * cox * sy;
        d[6] = -six * sy;

        d[8] = (-siy * coz + coy * six * siz) * sz;
        d[9] = (siz * siy + coy * six * coz) * sz;
        d[10] = coy * cox * sz;

        d[12] = tx;
        d[13] = ty;
        d[14] = tz;

        return m || this;
    }

    /**
     *  @method setScale
     *  @memberof SQR.Matrix44.prototype
     *  @description Sets the scale values.
     *  @param sx x scale
     *  @param sy y scale
     *  @param sz z scale
     *  @param m the matrix to set scale to, applies to `this` if ommited
     */
    this.setScale = function(sx, sy, sz, m) {
        var d = m || this.data;
        d[0] = sx,d[5] = sy,d[10] = sz;
        return m || this;
    }

    /**
     *  @method setTranslation
     *  @memberof SQR.Matrix44.prototype
     *  @description Sets the translation values.
     *  @param tx x translation
     *  @param ty y translation
     *  @param tz z translation
     *  @param m the matrix to set translation to, applies to `this` if ommited
     */
    this.setTranslation = function(tx, ty, tz, m) {
        var d = m || this.data;
        d[12] = tx, d[13] = ty, d[14] = tz;
        return m || this;
    }

    /**
     *  @method setRotation
     *  @memberof SQR.Matrix44.prototype
     *  @description Sets the rotation value.
     *  @param rx angle in radians of the rotation on x axis
     *  @param ry angle in radians of the rotation on y axis
     *  @param rz angle in radians of the rotation on z axis
     *  @param m the matrix to set shear to, applies to `this` if ommited
     */
    this.setRotation = function(rx, ry, rz, m) {
        var d = m || this.data;
        var six = Math.sin(rx), cox = Math.cos(rx), 
            siy = Math.sin(ry), coy = Math.cos(ry), 
            siz = Math.sin(rz), coz = Math.cos(rz);

        d[0] = coy * coz + siy * six * siz;
        d[1] = -coy * siz + siy * six * coz;
        d[2] = siy * cox;

        d[4] = siz * cox;
        d[5] = coz * cox;
        d[6] = -six;

        d[8] = -siy * coz + coy * six * siz;
        d[9] = siz * siy + coy * six * coz;
        d[10] = coy * cox;

        return m || this;
    }

    /** 
     *  @method translate
     *  @memberof SQR.Matrix44.prototype
     *  @description Applies translation to matrix
     *  @param tx x translation
     *  @param ty y translation
     *  @param tz z translation
     */
    this.translate = function(tx, ty, tz) {
        this.identity(SQR.Matrix44.__temp);
        this.setTranslation(tx, ty, tz, SQR.Matrix44.__temp);
        return this.multiply(SQR.Matrix44.__temp);
    }

    /** 
     *  @method rotate
     *  @memberof SQR.Matrix44.prototype
     *  @param rx angle in radians of the rotation on x axis
     *  @param ry angle in radians of the rotation on y axis
     *  @param rz angle in radians of the rotation on z axis
     *  @description Applies rotation to matrix
     */
    this.rotate = function(rx, ry, rz) {
        this.identity(SQR.Matrix44.__temp);
        this.setRotation(rx, ry, rz, SQR.Matrix44.__temp);
        return this.multiply(SQR.Matrix44.__temp);
    }

    /** 
     *  @method scale
     *  @memberof SQR.Matrix44.prototype
     *  @param sx x scale
     *  @param sy y scale
     *  @param sz z scale
     *  @description Applies scale to matrix
     */
    this.scale = function(sx, sy, sz) {
        this.identity(SQR.Matrix44.__temp);
        this.setScale(sx, sy, sz, SQR.Matrix44.__temp);
        return this.multiply(SQR.Matrix44.__temp);
    }

    /** 
     *  @method copyTo
     *  @memberof SQR.Matrix44.prototype
     *  Copies the values from this matrix into m
     *
     *  @param {SQR.Matrix44|Float32Array} m - the matrix or 16-compoment array to copy the values to
     */
    this.copyTo = function(m) {
        var a = this.data, b = m.data || m;
        for (var i = 0; i < 16; i++) b[i] = a[i];
        return m;
    }

    /** 
     *  @method copyRotationTo
     *  @memberof SQR.Matrix44.prototype
     *  Copies only the rotation/scale portion of the matrix into m to the current matrix
     *
     *  @param {SQR.Matrix44|Float32Array} m - the matrix or 16-compoment array to copy the values to
     */
    this.copyRotationTo = function(m) {
        var a = this.data, b = m.data || m;

        b[0] = a[0];
        b[1] = a[1];
        b[2] = a[2];

        b[3] = a[4];
        b[4] = a[5];
        b[5] = a[6];

        b[6] = a[8];
        b[7] = a[9];
        b[8] = a[10];

        return m;
    }

    /** 
     *  @method extractPosition
     *  @memberof SQR.Matrix44.prototype
     *  Sets v to the translation vakue of this matrix. Useful for extracting position of an element
     *  based on it's transformation matrix, ex. this is how the the global position of a {@link SQR.Transform} 
     *  is obtained.
     *
     *  @param {SQR.V3} v - the vector to copy the translation values to
     */
    this.extractPosition = function(v) {
        var d = this.data;
        v.set(d[12], d[13], d[14]);
        return v;
    }

    this.determinant = function() {
        var d = this.data;

        return d[0] * (d[5] * d[10] - d[9] * d[6]) +
            d[4] * (d[9] * d[2] - d[1] * d[10]) +
            d[8] * (d[1] * d[6] - d[5] * d[2]);
    }

    this.inverse = function(m) {
        var a = this.data;
        var d = (m) ? m.data || m : this.data;

        var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
            a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
            a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
            a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

            b00 = a00 * a11 - a01 * a10,
            b01 = a00 * a12 - a02 * a10,
            b02 = a00 * a13 - a03 * a10,
            b03 = a01 * a12 - a02 * a11,
            b04 = a01 * a13 - a03 * a11,
            b05 = a02 * a13 - a03 * a12,
            b06 = a20 * a31 - a21 * a30,
            b07 = a20 * a32 - a22 * a30,
            b08 = a20 * a33 - a23 * a30,
            b09 = a21 * a32 - a22 * a31,
            b10 = a21 * a33 - a23 * a31,
            b11 = a22 * a33 - a23 * a32,

            // Calculate the determinant
            det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

        if (!det) { 
            return null; 
        }
        det = 1.0 / det;

        d[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
        d[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
        d[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
        d[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
        d[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
        d[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
        d[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
        d[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
        d[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
        d[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
        d[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
        d[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
        d[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
        d[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
        d[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
        d[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;

        return m;
    };

    
    this.inverseMat3 = function(m) {
        // adapted from gl-Matrix.js
        var d = this.data;
        var a = m.data;
        var det = this.determinant();

        if (Math.abs(det) < 0.0001) {
            console.warn("> SQR.Matrix44 - Attempt to inverse a singular matrix44. ", this.data);
            console.trace();
            return m;
        }

        var d0 = d[0], d4 = d[4], d8 = d[8],   d12 = d[12],
            d1 = d[1], d5 = d[5], d9 = d[9],   d13 = d[13],
            d2 = d[2], d6 = d[6], d10 = d[10], d14 = d[14];

        det = 1 / det;

        // To make a NormalMatrix - needs to be transposed
        a[0] = (d5 * d10 - d9 * d6) * det;
        a[1] = (d8 * d6 - d4 * d10) * det;
        a[2] = (d4 * d9 - d8 * d5) * det;

        a[3] = (d9 * d2 - d1 * d10) * det;
        a[4] = (d0 * d10 - d8 * d2) * det;
        a[5] = (d8 * d1 - d0 * d9) * det;

        a[6] = (d1 * d6 - d5 * d2) * det;
        a[7] = (d4 * d2 - d0 * d6) * det;
        a[8] = (d0 * d5 - d4 * d1) * det;
        // m.transpose();

        // To make a NormalMatrix - doesn't need to be transposed
        // a[0] = (d5 * d10 - d9 * d6) * det;
        // a[3] = (d8 * d6 - d4 * d10) * det;
        // a[6] = (d4 * d9 - d8 * d5) * det;

        // a[1] = (d9 * d2 - d1 * d10) * det;
        // a[4] = (d0 * d10 - d8 * d2) * det;
        // a[7] = (d8 * d1 - d0 * d9) * det;

        // a[2] = (d1 * d6 - d5 * d2) * det;
        // a[5] = (d4 * d2 - d0 * d6) * det;
        // a[8] = (d0 * d5 - d4 * d1) * det;

        

        return m;
    }

    this.transpose = function(m) {
        var d = this.data;
        var a = (m) ? m.data || m : this.data;

        var d0 = d[0], d4 = d[4], d8 = d[8],
            d1 = d[1], d5 = d[5], d9 = d[9],
            d2 = d[2], d6 = d[6], d10 = d[10];

        a[0] = d0;
        a[1] = d4;
        a[2] = d8;

        a[4] = d1;
        a[5] = d5;
        a[6] = d9;

        a[8] = d2;
        a[9] = d6;
        a[10] = d10;
    }

    this.lookAt = function (target, up) {
        var d = this.data;
        var x = SQR.V3.__tv1;
        var y = SQR.V3.__tv2;
        var z = SQR.V3.__tv3;

        up = up || SQR.V3.up;

        // console.log(target, up);

        z.set(d[12], d[13], d[14]);
        z.sub(z, target).norm();
        if (z.magsq() === 0) z.z = 1;

        x.cross(up, z).norm();
        if (x.magsq() === 0) {
            z.x += 0.0001;
            x.cross(up, z).norm();
        }

        y.cross(z, x);

        d[0] = x.x, d[4] = y.x, d[8] = z.x;
        d[1] = x.y, d[5] = y.y, d[9] = z.y;
        d[2] = x.z, d[6] = y.z, d[10] = z.z;

        return this;
    }

    if(!data) this.identity();
}

SQR.Matrix44.__temp = new Float32Array(16);












/* --- --- [math/ProjectionMatrix.js] --- --- */

/**
 *  @class ProjectionMatrix
 *  @memberof SQR
 *
 *  @description The 4x4 matrix is a specialized 4x4 matrix used for perspective and orthographic projection.
 */
SQR.ProjectionMatrix = function() {
    if (typeof Float32Array == 'undefined') Float32Array = Array;
    this.data = new Float32Array(16);

    this.copyTo = function(m) {
        var a = this.data, b = m.data || m;
        for (var i = 0; i < 16; i++) b[i] = a[i];
        return m;
    }

    this.identity();
}

/**
 *  Resets the matrix to identity
 */
SQR.ProjectionMatrix.prototype.identity = function() {
    var m = this.data;
    m[0] = 1,m[1] = 0,m[2] = 0,m[3] = 0;
    m[4] = 0,m[5] = 1,m[6] = 0,m[7] = 0;
    m[8] = 0,m[9] = 0,m[10] = 1,m[11] = 0;
    m[12] = 0,m[13] = 0,m[14] = 0,m[15] = 1;
    return this;
}

/**
 *  Returns an orthographic projection matrix that is set in screen coordinates.
 */
SQR.ProjectionMatrix.prototype.screenPixels2d = function() {
    this.orthographic(0, window.innerWidth, 0, window.innerHeight, -1, 1000);
    return this;
}

/**
 *  Returns an orthographic projection matrix.
 */
SQR.ProjectionMatrix.prototype.orthographic = function(left, right, top, bottom, near, far) {

    var m = this.data;

     /**
     *  @property the near clipping
     *  @readonly
     */
    this.near = near;

    /**
     *  @property the far clipping
     *  @readonly
     */
    this.far = far;
    
    var w = right - left;
    var h = top - bottom;
    var p = far - near;

    var x = ( right + left ) / w;
    var y = ( top + bottom ) / h;
    var z = ( far + near ) / p;

    m[0] = 2 / w;    m[4] = 0;        m[8] = 0;        m[12] = -x;
    m[1] = 0;        m[5] = 2 / h;    m[9] = 0;        m[13] = -y;
    m[2] = 0;        m[6] = 0;        m[10] = -2/p;    m[14] = -z;
    m[3] = 0;        m[7] = 0;        m[11] = 0;       m[15] = 1;
    return this;
}

SQR.ProjectionMatrix.prototype.frustum = function (left, right, bottom, top, near, far) {

    var m = this.data;
    var x = 2 * near / ( right - left );
    var y = 2 * near / ( top - bottom );

    var a = ( right + left ) / ( right - left );
    var b = ( top + bottom ) / ( top - bottom );
    var c = - ( far + near ) / ( far - near );
    var d = - 2 * far * near / ( far - near );

    m[ 0 ] = x;    m[ 4 ] = 0;    m[ 8 ] = a;    m[ 12 ] = 0;
    m[ 1 ] = 0;    m[ 5 ] = y;    m[ 9 ] = b;    m[ 13 ] = 0;
    m[ 2 ] = 0;    m[ 6 ] = 0;    m[ 10 ] = c;   m[ 14 ] = d;
    m[ 3 ] = 0;    m[ 7 ] = 0;    m[ 11 ] = -1; m[ 15 ] = 0;

    return this;

}

SQR.ProjectionMatrix.prototype.perspective2 = function (fov, aspect, near, far) {

    var ymax = near * Math.tan(fov * Math.PI / 360);
    var ymin = - ymax;
    var xmin = ymin * aspect;
    var xmax = ymax * aspect;

    return this.frustum(xmin, xmax, ymin, ymax, near, far);

}

/**
 *  Returns a perspective projection matrix.
 */
SQR.ProjectionMatrix.prototype.perspective = function(fov, aspect, near, far) {

    /**
     *  @property the near clipping
     *  @readonly
     */
    this.near = near;

    /**
     *  @property the far clipping
     *  @readonly
     */
    this.far = far;

    var m = this.data;
    var t = near * Math.tan(fov * Math.PI / 360);
    var n = far - near;

    m[0] = near / (t * aspect);
    m[4] =  0;
    m[8] =  0;
    m[12] = 0;

    m[1] = 0;
    m[5] = near / t;
    m[9] = 0;
    m[13] = 0;

    m[2] = 0;
    m[6] = 0;
    m[10] = -(far + near) / n;
    m[14] = -(2 * far * near) / n;

    m[3] = 0;
    m[7] = 0;
    m[11] = -1;
    m[15] = 0;

    return this;
}

/**
 *  Returns vector mautipled by this matrix
 */
SQR.ProjectionMatrix.prototype.transformVector = function(v, pv) {
    var x = v.x, y = v.y, z = v.z, w = v.w;
    var m = this.data;
    pv = pv || v;

    pv.x = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
    pv.y = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
    pv.z = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
//  pv.w = d[3] * x + d[7] * y + d[11] * z + d[15] * w;

    return pv;
}

/**
 *  Inverses the matrix. Useful for projecting screen coordinates back in to 3d space.
 */
SQR.ProjectionMatrix.prototype.inverse = function (m) {
    var mat = this.data;
    m = m || this.data;

    var a00 = mat[0], a01 = mat[1], a02 = mat[2], a03 = mat[3],
        a10 = mat[4], a11 = mat[5], a12 = mat[6], a13 = mat[7],
        a20 = mat[8], a21 = mat[9], a22 = mat[10], a23 = mat[11],
        a30 = mat[12], a31 = mat[13], a32 = mat[14], a33 = mat[15],

        b00 = a00 * a11 - a01 * a10,
        b01 = a00 * a12 - a02 * a10,
        b02 = a00 * a13 - a03 * a10,
        b03 = a01 * a12 - a02 * a11,
        b04 = a01 * a13 - a03 * a11,
        b05 = a02 * a13 - a03 * a12,
        b06 = a20 * a31 - a21 * a30,
        b07 = a20 * a32 - a22 * a30,
        b08 = a20 * a33 - a23 * a30,
        b09 = a21 * a32 - a22 * a31,
        b10 = a21 * a33 - a23 * a31,
        b11 = a22 * a33 - a23 * a32,

        d = (b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06),
        invDet;

    // Calculate the determinant
    if (!d) {
        return null;
    }
    invDet = 1 / d;

    m[0] = (a11 * b11 - a12 * b10 + a13 * b09) * invDet;
    m[1] = (-a01 * b11 + a02 * b10 - a03 * b09) * invDet;
    m[2] = (a31 * b05 - a32 * b04 + a33 * b03) * invDet;
    m[3] = (-a21 * b05 + a22 * b04 - a23 * b03) * invDet;

    m[4] = (-a10 * b11 + a12 * b08 - a13 * b07) * invDet;
    m[5] = (a00 * b11 - a02 * b08 + a03 * b07) * invDet;
    m[6] = (-a30 * b05 + a32 * b02 - a33 * b01) * invDet;
    m[7] = (a20 * b05 - a22 * b02 + a23 * b01) * invDet;

    m[8] = (a10 * b10 - a11 * b08 + a13 * b06) * invDet;
    m[9] = (-a00 * b10 + a01 * b08 - a03 * b06) * invDet;
    m[10] = (a30 * b04 - a31 * b02 + a33 * b00) * invDet;
    m[11] = (-a20 * b04 + a21 * b02 - a23 * b00) * invDet;

    m[12] = (-a10 * b09 + a11 * b07 - a12 * b06) * invDet;
    m[13] = (a00 * b09 - a01 * b07 + a02 * b06) * invDet;
    m[14] = (-a30 * b03 + a31 * b01 - a32 * b00) * invDet;
    m[15] = (a20 * b03 - a21 * b01 + a22 * b00) * invDet;

    return m;
};

/* --- --- [math/Quaternion.js] --- --- */

/**
 *  @class Quaternion
 *  @memberof SQR
 *
 *  @description Represents a quaternion with optionally setting the values directly.
 *
 *  Just as a reminder, given an angle `a` and an axis `x,y,z` 
 *  this is what the quaternion values are:
 *  @example
var q = new SQR.Quaternion();
var s = Math.sin(a / 2);
q.x = x * s;
q.y = y * s;
q.z = z * s;
q.w = Math.cos(a / 2);
 */
SQR.Quaternion = function(x, y, z, w) {
    this.set(w, x, y, z);
}

/**
 *  Set value of the Quaternion directly.
 */
SQR.Quaternion.prototype.set = function(x, y, z, w) {
    this.w = w || 1;
    this.x = x || 0;
    this.y = y || 0;
    this.z = z || 0;
    return this;
}

SQR.Quaternion.prototype.copyTo = function(p) {
    p.x = this.x;
    p.y = this.y;
    p.z = this.z;
    p.w = this.w;
    return this;
}

/**
 *  Copy the values from another quaternion.
 *  @param q the quaternion to copy values from
 */
SQR.Quaternion.prototype.copyFrom = function(q) {
    this.w = q.w;
    this.x = q.x;
    this.y = q.y;
    this.z = q.z;
    return this;
}

/**
 *  Resets the quaternion values to identity.
 */
SQR.Quaternion.prototype.identity = function() {
    this.set();
    return this;
}

/**
 * Multiplies rq (or this if no rq) by q
 * @param q
 * @param rq if not defined this is multiplied by q
 */
SQR.Quaternion.prototype.mul = function(q, rq) {
    rq = rq || this;

    var w = (rq.w * q.w - rq.x * q.x - rq.y * q.y - rq.z * q.z);
    var x = (rq.w * q.x + rq.x * q.w + rq.y * q.z - rq.z * q.y);
    var y = (rq.w * q.y - rq.x * q.z + rq.y * q.w + rq.z * q.x);
    var z = (rq.w * q.z + rq.x * q.y - rq.y * q.x + rq.z * q.w);

    rq.set(x, y, z, w);

    rq.normalize();

    return rq;
}

/**
 *  Sets the quaternion to point in the given direction.
 *  @param _dir the direction to look at
 *  @param _up the up vector
 */
SQR.Quaternion.prototype.lookAt = function(_dir, _up) {

    var dir = SQR.Quaternion.__tv1;
    var right = SQR.Quaternion.__tv2;
    var up = SQR.Quaternion.__tv3;

    _dir.copyTo(dir);
    _up.copyTo(up);

    dir.norm();

    // If direction is back, the returned quaternion is flipped. Not sure why, but that fixes it.
    if(dir.z == -1) {
        dir.x = 0.0001;
        dir.norm();
    }

    // Probably should do the orthonormalization but not sure how that works :)
    // tangent.sub(up, forward.mul(SQR.V3.dot(forward, up))).norm();
    right.cross(up, dir);
    up.cross(dir, right);

    this.w = Math.sqrt(1 + right.x + up.y + dir.z) * 0.5;
    var rc = 4 * this.w;
    this.x = (dir.y - up.z) / rc;
    this.y = (right.z - dir.x) / rc;
    this.z = (up.x - right.y) / rc;

    this.normalize();

    return this;
}

/**
 *  Creates a quaternion out of an angle axis representation.
 *  @param a angle in radians
 *  @param x x component of the axis
 *  @param y y component of the axis
 *  @param z z component of the axis
 */
SQR.Quaternion.prototype.fromAngleAxis = function(a, x, y, z) {
    var s = Math.sin(a / 2);
    this.x = x * s;
    this.y = y * s;
    this.z = z * s;
    this.w = Math.cos(a / 2);
}

/**
 *  Returns the magniture of the quaternion.
 */
SQR.Quaternion.prototype.mag = function() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
}

/**
 *  Normalizes the quaternion.
 */
SQR.Quaternion.prototype.normalize = function() {
    var n = this.mag();
    this.x /= n;
    this.y /= n;
    this.z /= n;
    this.w /= n;
}

/**
 *  That method doesn't do anything. 
 *  Check {SQR.Matrix44.TQS()} to see how to turn a 
 *  Quanternion into a matrix representation.
 *
 *  @todo Implement (or not... not sure how much this is needed)
 */
SQR.Quaternion.prototype.toMatrix = function(m) {
    throw "SQR.Quaternion.toMatrix() is not implemented. Check SQR.Matrix44.TQS()"; 
}

/**
 *  Returns a spherical linear interpolation between two quaternions.
 *  @param qa first quaternion
 *  @param qb second quaternion
 *  @param t interpolation value [0-1]
 *  @param qr the quaterion to store the results in and return. If omitted results are returned in a new quaternion object.
 */
SQR.Quaternion.slerp = function(qb, qa, t, qr) {
    qr = qr || new SQR.Quaternion();

    var cha = qa.w * qb.w + qa.x * qb.x + qa.y * qb.y + qa.z * qb.z;
    var ha = Math.acos(cha);
    var sha = Math.sqrt(1 - cha * cha);
    var ra = Math.sin((1 - t) * ha) / sha;
    var rb = Math.sin(t * ha) / sha;

    if (Math.abs(cha) >= 1) {
        // If angle is 0 (i.e cos(a) = 1) just
        // return the first quaternion
        ra = 1;
        rb = 0;
    } else if (Math.abs(sha) < 0.001) {
        // If angle is 180 deg (i.e. sin(a) = 0) there is
        // an infinite amount of possible rotations between those 2
        ra = 0.5;
        rb = 0.5;
    }

    qr.w = (qa.w * ra + qb.w * rb);
    qr.x = (qa.x * ra + qb.x * rb);
    qr.y = (qa.y * ra + qb.y * rb);
    qr.z = (qa.z * ra + qb.z * rb);
    return qr;
}

SQR.Quaternion.prototype.slerp = function(qa, qb, t) {
    SQR.Quaternion.slerp(qa, qb, t, this);
}

SQR.Quaternion.__tv1 = new SQR.Quaternion();
SQR.Quaternion.__tv2 = new SQR.Quaternion();
SQR.Quaternion.__tv3 = new SQR.Quaternion();
















/* --- --- [math/Spline.js] --- --- */

/**
 *  @class Spline
 *  @memberof SQR
 *
 *  @description Represents a spline composed of multiple cubic beziers
 */
SQR.Spline = function() {

	var points = [];
	var segments = [];
	var controlPoints = [];

	var s = {};

	var _tv1, _tv2;

	var getControlPoints = function(point, previous, next, c1, c2, smoothness) {
		var vab = _tv1.sub(point, previous).neg();
		var vcb = _tv2.sub(point, next);
		var d = (smoothness > 1) ? smoothness : smoothness * Math.min(vab.mag(), vcb.mag());
		c1.set().add(vab, vcb).norm().mul(d);
		c2.copyFrom(c1).neg();
		c1.add(c1, point);
		c2.add(c2, point);
	}

	s.addSegment = function(p) {
		var v;

		if(p.x) {
			v = p;
		} else {
			var a = arguments, l = a.length;
			if(l == 2) v = new SQR.V2(a[0], a[1]);
			else if(l == 3) v = new SQR.V3(a[0], a[1], a[2]);
		}

		segments.push(v);
		controlPoints.push(v.clone(), v.clone());

		if(!_tv1) {
			_tv1 = segments[0].clone();
			_tv2 = segments[0].clone();
		}

		return s;
	}

	s.create = function(smoothness, close) {

		if(segments.length < 2) return segments;

		smoothness = (smoothness !== null) ? smoothness : 0.5;
		points.length = 0;
		var firstPoint, firstControlPoint;

		var sg = segments, cp = controlPoints, sl = segments.length;
		
		for(var i = 0; i < sl; i++) {
			var si = sg[i];
			var c1 = cp[i * 2].set();
			var c2 = cp[i * 2 + 1].set();

			var a = (i == 0) ? sg[sl-1] : sg[i-1];
			var b = (i == sl-1) ? sg[0] : sg[i+1];

			getControlPoints(si, a, b, c1, c2, smoothness);
			cp.push(c1, c2);
		}

		for(var i = 0; i < sl-1; i++) {
			var a = sg[i];
			var b = (i == sl-1) ? sg[0] : sg[i+1];

			var c1 = (i == 0 && !close) ? a : cp[i * 2 + 1];
			var c2 = (i == sl-2 && !close) ? b : cp[i * 2 + 2];

			var c = new SQR.Bezier(a, c1, c2, b);
			points.push(c);
		}

		if(close) {
			var c = new SQR.Bezier(sg[sl-1], cp[(sl-1)*2+1], cp[0], sg[0]);
			points.push(c);
		}

		return s;
	}

	s.valueAt = function(t, v) {
		if(t == 1) t = 0.999999;
		t = t % 1;
		var tf = t * points.length;
		return points[tf | 0].valueAt(tf % 1, v);
	}

	s.velocityAt = function(t, v) {
		if(t == 1) t = 0.999999;
		t = t % 1;
		var tf = t * points.length;
		return points[tf | 0].velocityAt(tf % 1, v);
	}

	s.matrixAt = function(t, m) {
		if(t == 0) t = SQR.EPSILON;
		if(t == 1) t = 1 - SQR.EPSILON;
		t = t % 1;
		var tf = t * points.length;
		return points[tf | 0].matrixAt(tf % 1, m);
	}

	Object.defineProperty(s, 'segments', {
		get: function() { 
			return segments; 
		}
	});

	Object.defineProperty(s, 'points', {
		get: function() { 
			return points; 
		}
	});

	return s

}

/* --- --- [math/Triangle.js] --- --- */

/**
 *  @class Triangle
 *  @memberof SQR
 *
 *  @description Represents a triangle composed on 3 vectors. 
 *	Vectors can be of any size, though some of it methods only work with 2-dimensional vectors.
 *
 *	@param v1 Vector {@link SQR.V2} or {@link SQR.V3}
 *
 *	@property {SQR.V2} centroid - the centroid, undef until `calculateCentroid` is called.
 *	@property {Number} circumRadius - the  radius of the 
 *		circum-circle, undef until `calculateCircumCircle` is called.
 *	@property {SQR.V2} circumCenter - the center of the cirsum-circle, 
 *		undef until `calculateCircumCircle` is called.
 *	
 */
SQR.Triangle = function(v0, v1, v2) {

	this.v0 = v0;
	this.v1 = v1;
	this.v2 = v2;

	/**
	 *	Calculates the centroid for this triangle. Only works with 2d coordinates for now.
	 *	The resulting centroid is stored in the `centroid` property.
	 *
	 *	@memberof SQR.Triangle.prototype
	 *	@method calculateCentroid
	 */
	this.calculateCentroid = function() {
		this.centroid = new SQR.V2();
		this.centroid.x = (this.v0.x + this.v1.x + this.v2.x) / 3;
		this.centroid.y = (this.v0.y + this.v1.y + this.v2.y) / 3;
	}

	/**
	 *	Calculates circumcircle, only works with 2d coordinates.
	 *	<br><br>
	 *	Based on 
	 *	{@link http://jwilson.coe.uga.edu/emat6680/dunbar/assignment4/assignment4_kd.htm this}
	 *	and
	 *	{@link http://www.exaflop.org/docs/cgafaq/cga1.html this}.
	 *
	 *	@memberof SQR.Triangle.prototype
	 *	@method calculateCircumCircle
	 */
	this.calculateCircumCircle = function() {
		var A = this.v1.x - this.v0.x;
		var B = this.v1.y - this.v0.y;
		var C = this.v2.x - this.v0.x;
		var D = this.v2.y - this.v0.y;

		var E = A * (this.v0.x + this.v1.x) + B * (this.v0.y + this.v1.y);
		var F = C * (this.v0.x + this.v2.x) + D * (this.v0.y + this.v2.y);

		var G = 2.0 * (A * (this.v2.y - this.v1.y) - B * (this.v2.x - this.v1.x));

		var dx, dy;

		if (Math.abs(G) < SQR.EPSILON) {
			// Collinear - find extremes and use the midpoint
			var minx = Math.min(this.v0.x, this.v1.x, this.v2.x);
			var miny = Math.min(this.v0.y, this.v1.y, this.v2.y);
			var maxx = Math.max(this.v0.x, this.v1.x, this.v2.x);
			var maxy = Math.max(this.v0.y, this.v1.y, this.v2.y);

			this.circumCenter = new SQR.V2((minx + maxx) / 2, (miny + maxy) / 2);

			dx = this.circumCenter.x - minx;
			dy = this.circumCenter.y - miny;
		} else {
			var cx = (D * E - B * F) / G;
			var cy = (A * F - C * E) / G;

			this.circumCenter = new SQR.V2(cx, cy);

			dx = this.circumCenter.x - this.v0.x;
			dy = this.circumCenter.y - this.v0.y;
		}

		this.circumRadiusSq = dx * dx + dy * dy;
		this.circumRadius = Math.sqrt(this.circumRadiusSq);
	}

	/**
	 *	Test whether the point v is inside the triangles circumcircle. 
	 *	If circum-circle was not calculated, calculateCircumCircle will be called first
	 *	@memberof SQR.Triangle.prototype
	 *	@method vertexInCircumcircle
	 *	@param {SQR.V2} v - vertex to be checked
	 *	@returns {boolean} true is vertex is in circumcircle
	 */
	this.vertexInCircumcircle = function(v) {

		if(!this.circumCenter) this.calculateCircumCircle();

		var dx = this.circumCenter.x - v.x;
		var dy = this.circumCenter.y - v.y;
		var sq = dx * dx + dy * dy;
		return (sq <= this.circumRadiusSq);

	}

};

/* --- --- [math/Vector2.js] --- --- */

/**
 *  @class V2
 *  @memberof SQR
 *
 *  @description A 2-dimensional vector
 *
 */
SQR.V2 = function(x, y) {
    this.set(x, y);
    this.size = 2;
}

SQR.V2.prototype.set = function(x, y) {
    this.x = x || 0;
    this.y = y || 0;
    return this;
}

SQR.V2.prototype.copyTo = function(p) {
    p.x = this.x;
    p.y = this.y;
    return p;
}

SQR.V2.prototype.copyFrom = function(p) {
    this.x = p.x;
    this.y = p.y;
    return this;
}

SQR.V2.prototype.clone = function() {
    return new SQR.V2(this.x, this.y);
}

SQR.V2.prototype.magsq = function() {
    return this.x * this.x + this.y * this.y;
};

SQR.V2.prototype.mag = function() {
    return Math.sqrt(this.magsq());
};

SQR.V2.prototype.isZero = function() {
    return this.x == 0 && this.y == 0;
};

SQR.V2.prototype.mul = function(s) {
    this.x *= s;
    this.y *= s;
    return this;
}

SQR.V2.prototype.neg = function() {
    this.x = -this.x;
    this.y = -this.y;
    return this;
}

SQR.V2.prototype.norm = function() {
    var m = 1 / this.mag();
    this.set(this.x * m, this.y * m);
    return this;
}

/**
 * a.add(a, b).add(a, c) -> a + b + c
 *
 * @param a
 * @param b
 */
SQR.V2.prototype.add = function(a, b) {
    this.x = a.x + b.x;
    this.y = a.y + b.y;
    return this;
}

/**
 * a.sub(b, a) ->  a = from a to b
 *
 * @param a
 * @param b
 */
SQR.V2.prototype.sub = function(a, b) {
    this.x = a.x - b.x;
    this.y = a.y - b.y;
    return this;
}

SQR.V2.prototype.lerp = function(a, b, t) {
    this.x = a.x + (b.x - a.x) * t;
    this.y = a.y + (b.y - a.y) * t;
    return this;
}

SQR.V2.dot = function(a, b) {
    return (a.x * b.x + a.y * b.y)
}

SQR.V2.prototype.perp = function() {
    this.set(this.y, -this.x);
    return this;
}

SQR.V2.prototype.toUniform = function() {
    return this.toArray();
}

SQR.V2.prototype.toArray = function() {
    if(!this.array) this.array = new Float32Array(2);
    this.array[0] = this.x;
    this.array[1] = this.y;
    return this.array;
}

/* --- --- [math/Vector3.js] --- --- */

/**
 *  @class V3
 *  @memberof SQR
 *
 *  @descrption A 3-dimensional vector
 *
 */
SQR.V3 = function(x, y, z) {
    this.set(x, y, z)
    this.size = 3;
}

/**
 *  Sets the vector compoment to values. Note that this class has actually 4 not 3 compoments.
 *  @param x - the value of the x compoment
 *  @param y - the value of the y compoment
 *  @param z - the value of the z compoment
 *  @param w - the value of the homogeneous coordinate, defaults to 1 
 *      and leave it that way unless you really know what ypu are doing.
 */ 
SQR.V3.prototype.set = function(x, y, z, w) {
    this.x = x || 0;
    this.y = y || 0;
    this.z = z || 0;
    this.w = w || 1;
    return this;
}

/**
 *  Copies values from this vector into the p vector
 *
 *  @param {SQR.V2|SQR.V3} p - vector to copy the values to
 */
SQR.V3.prototype.copyTo = function(p) {
    p.x = this.x;
    p.y = this.y;
    if(p.z != undefined) p.z = this.z;
    return p;
}

/**
 *  Copies values from vector p into this vector
 *
 *  @param {SQR.V2|SQR.V3} p - vector to copy the values from
 */
SQR.V3.prototype.copyFrom = function(p) {
    this.x = p.x;
    this.y = p.y;
    this.z = p.z || 0; // in case p is SQR.V2
    return this;
}

/**
 *  Creates and returns a copy of this vector. 
 *  Be careful with this method, because it creates a new object. 
 *  Calling this function repeatedly in a rendering loop can have an adverce impact on performance.
 *
 *  @returns {SQR.V3} a new vector that is a copy of this vector
 */
SQR.V3.prototype.clone = function() {
    return new SQR.V3(this.x, this.y, this.z);
}

/** 
 *  Returns the squared length of this vector. This can be useful to optimize some calculations, since
 *  the actual length requires a squareroot operation (`Math.sqrt()`) 
 *  which can be slow if used on many vectors.
 */
SQR.V3.prototype.magsq = function() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
};

/**
 *  Return the length (magnitude) of this vector
 *  @returns {Number} the length of this vector
 */
SQR.V3.prototype.mag = function() {
    return Math.sqrt(this.magsq());
};

/**
 *  Shorthand to check if this vector is a zero vector 
 *  (i.e. all compoments are very small or equal to 0) The values are compared against SQR.EPSILON
 */
SQR.V3.prototype.isZero = function() {
    return 
        Math.abs(this.x) < SQR.EPSILON && 
        Math.abs(this.y) < SQR.EPSILON && 
        Math.abs(this.z) < SQR.EPSILON;
};

/**
 *  Multiples this vector by a scalar. 
 *  This function can be used in conjunction with {@link SQR.V3#norm} 
 *  to set the vector to a given length `v.norm().mul(10)1 yields a vector of length 10.
 *
 *  @param {Number} s - the value to multiply the the vector by.
 */
SQR.V3.prototype.mul = function(s) {
    this.x *= s;
    this.y *= s;
    this.z *= s;
    return this;
}

/**
 *  Negates this vector.
 */
SQR.V3.prototype.neg = function() {
    this.x = -this.x;
    this.y = -this.y;
    this.z = -this.z;
    return this;
}

/**
 *  Normalizes this vector, i.e. sets its length (magnitude) to 1.
 */
SQR.V3.prototype.norm = function() {
    var m = 1 / this.mag();
    this.set(this.x * m, this.y * m, this.z * m);
    return this;
}

/**
 *  Sets this vector to the sum of a and b. 
 *
 *  @example
a.add(b, c); // a = b + c
a.add(a, b); // a += b
a.add(a, b).add(a, c); // = a + b + c
 *
 *  @param {SQR.V3} a
 *  @param {SQR.V3} b
 */
SQR.V3.prototype.add = function(a, b) {
    this.x = a.x + b.x;
    this.y = a.y + b.y;
    this.z = a.z + b.z;
    return this;
}

/**
 * a.sub(b, a) ->  a = from a to b
 *
 * @param a
 * @param b
 */
SQR.V3.prototype.sub = function(a, b) {
    this.x = a.x - b.x;
    this.y = a.y - b.y;
    this.z = a.z - b.z;
    return this;
}

SQR.V3.prototype.lerp = function(a, b, t) {
    this.x = a.x + (b.x - a.x) * t;
    this.y = a.y + (b.y - a.y) * t;
    this.z = a.z + (b.z - a.z) * t;
    return this;
}

SQR.V3.prototype.random = function() {
    this.x = Math.random() * 2 - 1;
    this.y = Math.random() * 2 - 1;
    this.z = Math.random() * 2 - 1;
    return this;
}

/**
 *  Returns the dot product of a nd b (`a . b`).
 *  @returns {Number} result of a . b
 */
SQR.V3.dot = function(a, b) {
    return a.x * b.x + a.y * b.y + a.z * b.z;
}

/**
 *  Sets this vector to the result of a cross-product of a and b (`a x b`).
 */
SQR.V3.prototype.cross = function(a, b) {
    var x = a.y * b.z - a.z * b.y;
    var y = a.z * b.x - a.x * b.z;
    var z = a.x * b.y - a.y * b.x;
    this.set(x, y, z, this.w);
    return this;
}

/**
 *  @private
 *  @description Alias for toArray
 *
 *  @returns {Float32Array} array - the array holding the values of this vector
 */
SQR.V3.prototype.toUniform = function() {
    return this.toArray();
}

/**
 *  @private
 *  @description Lazily creates a Float32Array and stores 
 *  the components of this vector in the array.
 *  This is mostly used when the value of this vector is 
 *  passed as uniform to a shader
 *  (this function is called internally by the renderer).
 *
 *  @returns {Float32Array} array - the array holding the values of this vector
 */
SQR.V3.prototype.toArray = function() {
    if(!this.array) this.array = new Float32Array(3);
    this.array[0] = this.x;
    this.array[1] = this.y;
    this.array[2] = this.z; 
    return this.array;
}

/**
 *  Assuming the vector was projected using the {@link SQR.ProjectionMatrix}, use this
 *  to calculate it's screen space. (useful for software rendering, ex. on canvas 2d)
 *
 *  @param {Number=} w - the width of the screen (defaults to `window.innerWidth`) 
 *  @param {Number=} h - the height of the screen (defaults to `window.innerHeight`) 
 */
SQR.V3.prototype.toScreenSpace = function(w, h) {
    w = w || window.innerWidth;
    h = h || window.innerHeight;
    this.x = (this.x / this.z) * w/2 + w/2;
    this.y = (this.y / this.z) * h/2 + h/2;
}

/**
 *  Use this for caculating per-vertex normals. 
 *  A normal from each contributing face can be added here. 
 *  When all the normals are added, a vector that is the sum of them all 
 *  is available as `this.normal` property. The pre-vertex normal can be caluculated
 *  but normalizing this vector.
 */
SQR.V3.prototype.addNormal = function(_n) {

    if(!this.normal) {
        this.normal = new SQR.V3();
    }

    this.normal.add(this.normal, _n);
}

/** 
 *  This is use to reset the normal to 0.
 */
SQR.V3.prototype.resetNormal = function(_n) {
    if(this.normal) this.normal.set();
}


/**
 *  @const
 *  @memberof SQR.V3
 *  @description A constant the defines the up vector. 
 *  WARNING: be extremly careful not to modify the values of this vector, because this will cause some
 *  matrix functions, like {@link SQR.Matrix44#lookAt} to not fuction properly.
 */
SQR.V3.up = new SQR.V3(0,1,0);

/**
 *  @const
 *  @memberof SQR.V3
 *  @description A constant the defines the forward vector. 
 *  WARNING: be extremly careful not to modify the values of this vector, because this will cause some
 *  matrix functions to not fuction properly.
 */
SQR.V3.forward = new SQR.V3(0,0,1);

SQR.V3.__tv1 = new SQR.V3();
SQR.V3.__tv2 = new SQR.V3();
SQR.V3.__tv3 = new SQR.V3();

/* --- --- [two/CanvasRenderer.js] --- --- */

/**
 *  @class CanvasRenderer
 *  @memberof SQR
 *
 *  @description Part of a minimal Canvas 2d rendering engine. The paremeter is a canvas element or a selector (ex. #gl-canvas) 
 *	can be passed to this function. If omitted a new canvas element will be created
 *	and it will be available as the canvas property of the object.
 *
 *	@param {HTMLCanvasElement} the underlying canvas element
 *	@property {HTMLCanvasElement} the underlying canvas element
 */
SQR.CanvasRenderer = function(canvas) {

	var r = {};

	var BADCTX = "> SQR.Context - Invalid canvas reference.";

	if(!canvas) canvas = document.createElement('canvas');
	if(!(canvas instanceof HTMLElement)) canvas = document.querySelector(canvas);
	if(!canvas.getContext) throw BADCTX;

	var ctx = canvas.getContext('2d');

	// Dash line shim
	if(!ctx.setLineDash) ctx.setLineDash = function() {};

	r.canvas = canvas;

	/** 
	 *	Set the size of the underlying canvas element.
	 *	@method setSize
	 *	@memberof SQR.CanvasRenderer.prototype
	 *	@param {Number} w - the width of the canvas
	 *	@param {Number} h - the height of the canvas
	 */
	r.setSize = function(w, h) {
		canvas.width = w;
		canvas.height = h;
	}

	/**
	 *	Render the transform tree
	 *	@method render
	 *	@memberof SQR.CanvasRenderer.prototype
	 *	@param {SQR.Transform2d} root - the root transform to render
	 */
	r.render = function(root) {
		ctx.clearRect(0, 0, canvas.width, canvas.height);
		root.draw(ctx);
	}

	return r;
}

/* --- --- [two/Shapes.js] --- --- */

SQR.Shapes = {

	circle: function(radius, color) {
		return function(ctx) {
			ctx.beginPath();
			ctx.fillStyle = color;
			ctx.arc(0, 0, radius, 0, Math.PI * 2);
			ctx.fill();
		}
	},

	triangleEq: function(radius, color) {
		return function(ctx) {
			ctx.fillStyle = color;
			ctx.beginPath();
			var r = radius;
			ctx.moveTo(Math.cos(30/180*Math.PI) * r, Math.sin(30/180*Math.PI) * r);
			ctx.lineTo(Math.cos(150/180*Math.PI) * r, Math.sin(150/180*Math.PI) * r);
			ctx.lineTo(Math.cos(Math.PI/-2) * r, Math.sin(Math.PI/-2) * r);
			ctx.fill();
		}
	},

	quad: function(width, height, color) {
		return function(ctx) {
			ctx.fillStyle = color;
			ctx.fillRect(width*-0.5, height*-0.5, width, height);
		}
	}

}

/* --- --- [two/Transform2d.js] --- --- */

/**
 *  @class Transform2d
 *  @memberof SQR
 *
 *  @description Similar to {SQR.Transform} but specialized to work with 2d rendeirng on a 2d canvas element.
 *  
 */
SQR.Transform2d = function() {

	var t = {};

	t.name = name || 'sqr.transform.' + SQR.Transform2dCount++;

    /** 
     *  @var {SQR.V3} position - the position of this transform relative to it's parent.
     *  It's a 3d vector, because z is used for depth indexing.
     *  @memberof SQR.Transform2d.prototype
     */
	t.position = new SQR.V3(0, 0, 0);

    /**
     *  @var {SQR.V3} rotation - the rotation of the transform in radians
     *  @memberof SQR.Transform2d.prototype
     */
	t.rotation = 0;

    /**
     *  @var {SQR.V2} scale - the scale of the object on x and y axis
     *  @memberof SQR.Transform2d.prototype
     */
	t.scale = new SQR.V2(1, 1);

    /**
     *  @var {Number} alpha - the transparency of this element. 
     *  0 = transparent, 1 = opaque, default 1
     */
    t.alpha = 1;

	t.children = [], t.numChildren = 0;

   /**
    *   @method add
    *   @memberof SQR.Transform2d.prototype
    *   
    *   @description Add a child transform. Accepts multiple arguments but all of them need to be of type {SQR.Transform2D}.
    *   It doesn't do any sort of type checking so if you add non object that are not {SQR.Transform2D} 
    *   it will result in errors when the scene is rendered.
    */
    t.add = function() {
        for (var i = 0; i < arguments.length; i++) {
            var c = arguments[i];
            c.parent = t;
            if (t.children.indexOf(c) == -1) t.children.push(c);
        }
        t.numChildren = t.children.length;
        return t;
    }

    /**
     *  @method remove
     *  @memberof SQR.Transform2d.prototype
     *   
     *  @description Removes a child transform. Accepts multiple arguments 
     *  but all of them need to be of type {SQR.Transform2D}
     */
    t.remove = function() {
        for (var i = 0; i < arguments.length; i++) {
            var c = arguments[i];
            var j = t.children.indexOf(c);
            if (j == -1) return false;
            c.parent = null;
            t.children.splice(j, 1);
        }
        t.numChildren = t.children.length;
        return t;
    }

    /**
     *  @method removeAll
     *  @memberof SQR.Transform2d.prototype
     *   
     *  @description Removes all children transform.
     */
    t.removeAll = function() {
        t.children.length = 0;
        t.numChildren = 0;
    }

    /**
     *  @method contains
     *  @memberof SQR.Transform2d.prototype
     *   
     *  @description Checks if transform is child of this transfom
     *  @param {SQR.Transform2D} c the transform to look for
     */
    t.contains = function(c) {
        return t.children.indexOf(c) > -1;
    }

    /**
     *  @method recurse
     *  @memberof SQR.Transform2d.prototype
     *   
     *  @description Execute this function on all the child transforms including this current one.
     *
     *  @param {function} f the function that will be called on each child. 
     *  This function will receive the transform as argument.
     *
     *  @param {boolean} excludeSelf if set to true, the function will only be called for all 
     *  the ancestors of the Transform.
     */
    t.recurse = function(f, excludeSelf) {
       if(!excludeSelf) f(t);
        for (var i = 0; i < t.numChildren; i++) {
            t.children[i].recurse(f);
        }
    }

    t.draw = function(context) {
        var c = context;

    	c.save();
    	c.translate(t.position.x, t.position.y);
    	c.rotate(t.rotation);
    	// First draw the children, then self, so that alpha/scale do not affect children
    	for(var i = 0; i < t.numChildren; i++) t.children[i].draw(c);

        if(t.alpha < 1) c.globalAlpha = t.alpha;
        c.scale(t.scale.x, t.scale.y);
        if(t.shape) t.shape(c);

    	c.restore();
	}

	return t;
}

SQR.Transform2dCount = 0;









