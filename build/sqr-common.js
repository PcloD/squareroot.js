/* --- --- [SQR.js] --- --- */

/**
 *	@namespace SQR
 *	@description The global engine namesapce. All classes belong to this namespace.
 */
SQR = {

	/**
	 *	@property TWOPI - shorthand for `Math.PI * 2`
	 */
	TWOPI: Math.PI * 2,

	/**
	 *	@property TWOPI - shorthand for `Math.PI * 0.5`
	 */
	HALFPI: Math.PI * 0.5,

	/**
	 *	@property EPSILON - a very small number, used to prevent rounding errors
	 */
	EPSILON: 1.0e-6,

	/**
	 *	@property gl - Placeholder that holds current gl context. This is set in SQR.Context.create(), but can be modified manually too
	 */
	gl: null, 
	
	/** 
	 *	@property fullScreenQuad - placeholder that holds a fullscreen geometry for post effects. Lazily created in PostEffect.js
	 *	Typically not set manually.
	 */
	fullScreenQuad: null,

	/**
	 *	@property shaderPath - a path relative to the main HTML file where the src/glsl folder is located.
	 *	Only necessary to if builtin shader code is loaded (using ~ paths).
	 *
	 *	@default .
	 */
	shaderPath: '.',

	/**
	 *	@namespace Primitives
	 *	@memberof SQR
	 *	@description A collection of classes & functions and utilities to create geometries
	 */
	Primitives: {},

	// Typical mesh layouts
	// Commonly used attribute names are: aPosition, aColor, aNormal, aUV, aUV2...
	v2: function() { return { aPosition: 2 }; },
	v3: function() { return { aPosition: 3 }; },
	v2u2: function() { return { aPosition: 2, aUV: 2 }; },
	v2c3: function() { return { aPosition: 2, aColor: 3 }; },
	v3n3: function() { return { aPosition: 3, aNormal: 3 }; },
	v3n3u2: function() { return { aPosition: 3, aNormal: 3, aUV: 2 }; },

	// GL contstants (removed, because this stuff can be accessed via SQR.gl)
	// POINTS          : 0x0000,
	// LINES           : 0x0001,
	// LINE_LOOP       : 0x0002,
	// LINE_STRIP      : 0x0003,
	// TRIANGLES       : 0x0004,
	// TRIANGLE_STRIP  : 0x0005,
	// TRIANGLE_FAN	   : 0x0006,

    // Error reporting 

    // Issues a console.warn() is user attempts to set a uniform that does not exist on the shader
    WARN_UNIFORM_NOT_PRESENT : false 

};

/* --- --- [Version.js] --- --- */

/**
 *	@property Version - autogenerated with build script, holds current verison info
 */
// DO NOT EDIT. Updated from version.json
SQR.Version = {"version":"3","build":17,"date":"2015-01-09T02:17:15.950Z"}

/* --- --- [common/Buffer.js] --- --- */

/**
 *	@class Buffer
 *	@memberof SQR
 *
 *	@description A buffer represents a 2d or 3d geometry and an attribute buffer.
 *	A buffer is internally composed of a Float32Array array and a WebGL buffer object.
 *	Squareroot does rely on strides, so each geometry is only composed of one array/buffer.
 *	A stride is a portion of the array that holds data for all attributes in a specific order.
 *	For example if the geometry is composed of 3D vertices, normals and 2D UV coordinates, 
 *	the stride look like this<br>
 *	`vx, vy, vz, nx, ny, nz, u, v`<br>
 *	The creation of strides in handled internally by the Buffer class.
 *	<br><br>
 *	More info on strides can be found in the {@link https://www.khronos.org/registry/webgl/specs/latest/1.0/ specs}.
 *	<br><br>
 *	Please read the {@tutorial basic-setup} tutorial to see how to use a buffer  
 *	and the {@tutorial understanding-buffers} tutorial  for an in depth discussion on buffers.
 */
SQR.Buffer = function() {

	var b = {};
	var hasIndex = false;
	var data, indices;
	var buffer, indexBuffer;

	b.mode = SQR.gl.TRIANGLES;

	/**
	 *	@method setMode
	 *	@memberof SQR.Buffer.prototype
	 *
	 *	@description set the drawing mode for this buffer. 
	 *	Can be any one of the supported webgl drawing modes such as 
	 *	`gl.POINTS`, `gl.LINES` or `gl.TRIANGLES` which is the default.
	 *
	 *	Reminder: all the gl constants are available through the `SQR.gl` property.
	 */
	b.setMode = function(m) {
		b.mode = m
		return b;
	}

	/**
	 *	@method layout
	 *	@memberof SQR.Buffer.prototype
	 *	
	 *	@description Sets the layout of the buffer. 
	 *	A layout describes all the attributes of the geometry and their respective sizes. 
	 *	{@link SQR} has a few global functions that ar shorthands for typical layouts, like ex. {@link SQR.v2c3()}
	 *	@example 
var l = { aPosition: 3, aColor: 4, aUV: 2 };
// the `new` keyword is optional, all methods are chainable
var buffer = SQR.Buffer().layout(l, 100).update();
	 *
	 *	@param {object} layout - the layout of the buffer (see desc above) and {@tutorial understanding-buffers}
	 *	@param {Number} size - the size of the buffer i.e. how many vertices it has
	 *	
	 */
	b.layout = function(layout, size) {
		b.size = size;
		b.strideSize = 0;
		b.layout = layout;
		b.attributes = {};

		for(var a in layout) {
			var aa = { offset: b.strideSize, byteOffset: b.strideSize * 4, size: layout[a] };
			b.strideSize += layout[a];
			b.attributes[a] = aa;
		}

		b.strideByteSize = b.strideSize * 4;
		data = new Float32Array(size * b.strideSize);
		return b;
	}

	/**
	 *	@method data
	 *	@memberof SQR.Buffer.prototype
	 *
	 *	@description Sets all the data for a given attribute.
	 */
	b.data = function(attribute, array) {

		if(!(array instanceof Array)) {
			array = Array.prototype.slice.call(arguments, 1);
		}

		var s = b.attributes[attribute];
		var dl = array.length / s.size;

		for(var i = 0; i < dl; i++) {
			for(var j = 0; j < s.size; j++) {
				data[i * b.strideSize + j + s.offset] = array[i * s.size + j];
			}
		}

		return b;
	}

	/**
	 *	@method set
	 *	@memberof SQR.Buffer.prototype
	 *
	 *	@description Sets a value for an attribute at a defined position.
	 *
	 *	@param {string} attribute - name of the attribute (ex. `aPosition`)
	 *	@param {Number} position - the index of this attrbute (related to the size of the buffer)
	 *	@param {Array=} array - the data in form of an `Array` or as separate arguments 
	 *	or an object that has a `toArray` attribute (see example to see all the possible options)
	 *
	 *	@example
b.set('aPosition', 1, 	[3, 5, 6]);
b.set('aPosition', 1, 	4, 8, 9);
b.set('aPosition', 1, 	new SQR.V3(3, 5, 6));
	 */
	b.set = function(attribute, position, array) {
		if(array.toArray) {
			array = array.toArray();
		} else if(!(array instanceof Array)) {
			array = Array.prototype.slice.call(arguments, 2);
		}

		var s = b.attributes[attribute];

		for(var j = 0; j < s.size; j++) {
			data[position * b.strideSize + j + s.offset] = array[j];
		}

		return b;
	}

	/**
	 *	@method iterate
	 *	@memberof SQR.Buffer.prototype
	 *
	 *	@description Iterates over each value for a given attribute. 
	 *	See example to see how to move all the vertices by 4 on the Y axis.
	 *
	 *	@example
b.iterate('aPosition', function(i, data, count)) {
	// i = x, i+1 = y, i+2 = z
	data[i + 1] += 4;
});
	 */
	b.iterate = function(attribute, callback) {
		var s = b.attributes[attribute];
		var c = 0;

		for(var i = 0; i < data.length; i += b.strideSize) {
			callback(i + s.offset, data, c);
			c++;
		}
		return b;
	}

	/**
	 *	@method bind
	 *	@memberof SQR.Buffer.prototype
	 *
	 *	@description Binds the buffer in gl, 
	 *	which does the same thing as calling `gl.bindBuffer` directly.
	 */
	b.bind = function() {
		SQR.gl.bindBuffer(SQR.gl.ARRAY_BUFFER, buffer);
		return b;
	}

	/**
	 *	@method update
	 *	@memberof SQR.Buffer.prototype
	 *
	 *	@description Updates the webgl buffer with the data from the internal array. 
	 *	When called for the first time it lazily creates the webgl buffer.
	 */
	b.update = function() {
		var gl = SQR.gl;

		buffer = buffer || gl.createBuffer();
		gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW);

        if(hasIndex) {
        	indexBuffer = gl.createBuffer();
        	gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
        	gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);
        }

        return b;
	}

	/**
	 *	@method index
	 *	@memberof SQR.Buffer.prototype
	 *
	 *	@description Sets index data. 
	 *
	 *	@param {Array=} array either an array or argument list of all the indexes. 
	 *	Used when setting up meshes imported as OBJ or JSON object from Unity, Blender or similar.
	 */
	b.index = function(array) {

		if(!(array instanceof Array)) {
			array = Array.prototype.slice.call(arguments, 0);
		}

		indices = new Uint16Array(array);
		b.indexSize = array.length;
        hasIndex = true;

        return b;
	}

	/**
	 *	@method isIndexed
	 *	@memberof SQR.Buffer.prototype
	 *
	 *	@description returns true if buffer data is indexed and has an index array
	 */
	b.isIndexed = function() {
		return hasIndex;
	}

	/**
	 *	@method draw
	 *	@memberof SQR.Buffer.prototype
	 *
	 *	@description used by the {SQR.Renderer}, called when this geometry is drawn. 
	 *	Will call `gl.drawArrays` or `gl.drawElements` to draw the geometry using the current shader.
	 */
	b.draw = function() {
		var gl = SQR.gl;
		
		if(hasIndex)
			gl.drawElements(b.mode, b.indexSize, gl.UNSIGNED_SHORT, 0);
		else 
			gl.drawArrays(b.mode, 0, b.size);
	}

	/**
	 *	@method setRawData
	 *	@memberof SQR.Buffer.prototype
	 *
	 *	@description sets the raw data into the array at offset 
	 */
	b.setRawData = function(array, offset) {
		data.set(array, offset);
	}

	/**
	 *	@method getDataArray
	 *	@memberof SQR.Buffer.prototype
	 *
	 *	@description Returns the raw array data
	 *	
	 *	@data {Float32Array} - Array containing all the vertex attributes data organized in stride
	 *	according to the layout.
	 */
	b.getDataArray = function() {
		return data;
	}

	/**
	 *	@method destroy
	 *	@memberof SQR.Buffer.prototype
	 *
	 *	@description Destroys the buffer and clears all data from the array.
	 */
	b.destroy  = function() {
		data.length = 0;
		SQR.gl.deleteBuffer(buffer);

		if(hasIndex) {
			indices.length = 0;
			SQR.gl.deleteBuffer(indexBuffer);
		}
	}

	return b;

}

/* --- --- [common/Context.js] --- --- */

/**
 *	@class Context
 *	@memberof SQR
 *	
 *	@description When creating the Context object, a canvas element or a selector (ex. #gl-canvas) 
 *	can be passed to this function. If omitted a new canvas element will be created
 *	and it will be available as the canvas property of the object 
 *	returned by the SQR.Context functiom. See quick example below or read more in {@tutorial basic-setup}.
 *
 *	@example
// the `new` keyword is optional, all methods are chainable
var w = window.innerWidth, h = window.innerHeight;
var c = SQR.Context('#canvas').create().size(w, h).clearColor(0, 0, 0, 1);
 */
SQR.Context = function(canvas) {

	if(!SQR._versionDisplayed && SQR.Version) {
		console.log('Squareroot v' + SQR.Version.version + ' b' + SQR.Version.build);
		SQR._versionDisplayed = true;
	}
 
	var NOGL = "> SQR.Context - Webgl is not supported.";
	var BADCTX = "> SQR.Context - Invalid canvas reference.";

	if(!canvas) canvas = document.createElement('canvas');
	if(!(canvas instanceof HTMLElement)) canvas = document.querySelector(canvas);
	if(!canvas.getContext) throw BADCTX;

	var c = { 

		/**
		 *	@var {HTMLCanvasElement} canvas - Represents the canvas used to get the webgl context from.
		 *	@memberof SQR.Context.prototype
		 */
		canvas: canvas 
	}, gl;

	/**
	 *	@method create
	 *	@memberof SQR.Context.prototype
	 *	
	 *	@description Creates the webgl context. 
	 *	
	 *	@param options Options as defined in Specs, section 5.2.
	 *	Passing the options is not mandatory, if uses default values otherwise.
	 *	@link https://www.khronos.org/registry/webgl/specs/latest/1.0/#5.2
	 *	
	 *	@param onError callback in case WebGL is not supported
	 *	if ommited, this function will throw (see below) a error if there are problems.
	 *
	 *	@throws error is webgl context cannot be created (ex. webgl is not supported)
	 *
	 *	@returns SQR.Context
	 */
	c.create = function(options, onError) {

		onError = onError || function() { throw NOGL; };

		options = options || {};
		if(options.antialias === undefined) options.antialias = true;

		if(!window.WebGLRenderingContext) onError()

		try {
			gl = canvas.getContext('webgl', options) || canvas.getContext('experimental-webgl', options);
	    } catch(e) { 
	    	console.error(e);
	    	onError();
	    } 

		c.gl = gl;
        c.setAsCurrent();
		return c;
	}

	/** 
	 *	Sets the canvas and the viewport size to the given values.
	 */
	c.size = function(w, h) {
		canvas.width = w;
		canvas.height = h;
		gl.viewport(0, 0, w, h);
		return c;
	}

	/**
	 *	Define clear color. 
	 *	r, g, b, a are in [0-1] range.
	 */
	c.clearColor = function(r, g, b, a) {
		gl.clearColor(r, g, b, a);
		return c;
	}

	/**
	 *	Quick viewport clear function - clears both color and depth buffers.
	 *	Typically called at each frame before rendering to screen.
	 *	For custom clearing options use SQR.gl.clear()
	 */
	c.clear = function() {
		gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
		return c;
	}

	/**
	 *	Sets this context as current in the global SQR.gl variable.
	 *	This variable is used by the engine to perform rendering.
	 */
	c.setAsCurrent = function() {
		SQR.gl = gl;
		return c;
	}

	return c;
}

/* --- --- [common/Cubemap.js] --- --- */

/**
 *  @class Cubemap
 *  @memberof SQR
 *
 *  @descrption A cubemap texture is used for texturing reflections, skyboxes and similar effects. If your shader expects a cubemap uniform use this object to create one.
 *  @param faces {Object} 6 paths to the textures for each face.
 *  @param faces.up {string} the path to the image for the face up
 *  @param faces.down {string} the path to the image for the face down
 *  @param faces.left {string} the path to the image for the face left
 *  @param faces.right {string} the path to the image for the face right
 *  @param faces.back {string} the path to the image for the face back
 *  @param faces.front {string} the path to the image for the face front
 *
 *  @param params {object} parameter for the texture
 *  @param params.onLoad {function} a callback to call when all the images are loaded 
 */
SQR.Cubemap = function(faces, params) {

    var c = {};
    c.tex = SQR.gl.createTexture();

    var facesLeft = 6;
    var faceImages = {};

    params = params || {};

    var onLoad = function() {

    	var gl = SQR.gl;

        gl.bindTexture(gl.TEXTURE_CUBE_MAP, c.tex);

        // gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, c.flip);

        gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, faceImages.right);
        gl.texImage2D(gl.TEXTURE_CUBE_MAP_NEGATIVE_X, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, faceImages.left);

        gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_Y, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, faceImages.up);
        gl.texImage2D(gl.TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, faceImages.down);

        gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_Z, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, faceImages.front);
        gl.texImage2D(gl.TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, faceImages.back);

        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, gl.LINEAR);

        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

        gl.generateMipmap(gl.TEXTURE_CUBE_MAP);

        gl.bindTexture(gl.TEXTURE_CUBE_MAP, null);

        if (params.onLoad) params.onLoad();
    }

    var onFace = function() {
        facesLeft--;
        if (facesLeft <= 0) onLoad();
    }

    var load = function(name, src) {

        if (typeof(src) == "string") {
            faceImages[name] = new Image();
            faceImages[name].onload = onFace;
            faceImages[name].src = src;
        } else if (src instanceof Image || !!src.getContext) {
            faceImages[name] = src;
            onFace();
        }
    }

    if (faces.left) {
        load("left", faces.left);
        load("right", faces.right);
        load("up", faces.up);
        load("down", faces.down);
        load("back", faces.back);
        load("front", faces.front);
    } else {
        load("left", faces);
        load("right", faces);
        load("up", faces);
        load("down", faces);
        load("back", faces);
        load("front", faces);
    }

    return c;
}

/* --- --- [common/FrameBuffer.js] --- --- */

/**
 *  @class FrameBuffer
 *  @memberof SQR
 *  
 *  @description A FrameBuffer is used in render-to-texture, image effects and other advances rendering schemes.
 *
 *  @params width The width of the frame buffer
 *  @params height The height of the frame buffer
 */
SQR.FrameBuffer = function(width, height, resolution, isCubemap) {

    resolution = resolution || 1;

    var f = {}, gl = SQR.gl;

    f.texture = gl.createTexture();
    f.depthBuffer = gl.createRenderbuffer();

    // bind & setup texture
    if(!isCubemap) {
        f.fbo = gl.createFramebuffer();
        gl.bindFramebuffer(gl.FRAMEBUFFER, f.fbo);
        gl.bindTexture(gl.TEXTURE_2D, f.texture);

        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);

        // bind render buffer
        gl.bindRenderbuffer(gl.RENDERBUFFER, f.depthBuffer);
        gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, width, height);

        // attach texture and render buffer to fbo
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, f.texture, 0);
        gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, f.depthBuffer);

        // unbind all
        gl.bindTexture(gl.TEXTURE_2D, null);
        gl.bindRenderbuffer(gl.RENDERBUFFER, null);
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    } else {
        // based on http://jsperf.com/webgl-cubemap-fbo-change-face-test
        gl.bindTexture(gl.TEXTURE_CUBE_MAP, f.texture);

        // gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);

        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, gl.LINEAR);

        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

        for (var i = 0; i < 6; i++) {
            gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
        }
    
        gl.bindRenderbuffer(gl.RENDERBUFFER, f.depthBuffer);
        gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, width, height);
        
    
        var makeFace = function(index) {
            var fbo = gl.createFramebuffer();
            gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_CUBE_MAP_POSITIVE_X + index, f.texture, 0);
            gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, f.depthBuffer);
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            return fbo;
        };

        f.faces = {
            right: makeFace(0),
            left: makeFace(1),
            up: makeFace(2),
            down: makeFace(3),
            front: makeFace(4),
            back: makeFace(5),
        };

        gl.bindTexture(gl.TEXTURE_2D, null);
        gl.bindRenderbuffer(gl.RENDERBUFFER, null);
    }

    f.bind = function(name) {
        var fbo = (f.faces) ? f.faces[name] : f.fbo;
        gl.viewport(0, 0, width, height);
        gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
    }

    f.resize = function(w, h) {
        width = (w * resolution) | 0;
        height = (h * resolution) | 0;

        gl.bindFramebuffer(gl.FRAMEBUFFER, f.fbo);
        gl.bindTexture(gl.TEXTURE_2D, f.texture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);

        gl.bindRenderbuffer(gl.RENDERBUFFER, f.depthBuffer);
        gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, width, height);
    }

    return f;
}


/* --- --- [common/Loader.js] --- --- */

/**
 *	@namespace Loader
 *	@memberof SQR
 *
 *	@description Utility to load different types of files (and also some WebRTC related stuff, see below)
 */
SQR.Loader = {

	/** 
	 *	@method load
	 *	@memberof SQR.Loader
	 *
	 *	@description Load a text file and return it's contents in the callback.
	 */
	loadText: function(path, callback){
		var request = new XMLHttpRequest();
		request.open("GET", path);

		var onReadystatechange = function(){
			if (request.readyState == 4) {
				request.removeEventListener('readystatechange', onReadystatechange);
				callback(request.responseText, path);
			}
		}

		request.addEventListener('readystatechange', onReadystatechange);

		request.send();
	},

	/** 
	 *	@method loadJSON
	 *	@memberof SQR.Loader
	 *
	 *	@description Load a JSON file and return it's contents in the callback.
	 *	This function will parse the JSON data for you and return an Object.
	 */
	loadJSON: function(path, callback){
		SQR.Loader.loadText(path, function(text) {
			callback(JSON.parse(text), path);
		});
	},

	/** 
	 *	@method loadImage
	 *	@memberof SQR.Loader
	 *
	 *	@description Load an image file and return it's contents in the callback
	 *	as Image object.
	 */
	loadImage: function(path, callback){
		var img = new Image();
		if(callback) {
			var onload = function() {
				img.removeEventListener('load', onload);
				callback(img, path);
			}
			img.addEventListener('load', onload);
		}
		img.src = path;
		return img;
	},

	/** 
	 *	@method loadWebcam
	 *	@memberof SQR.Loader
	 *
	 *	@description Initiate user stream (webcam). 
	 */
	loadWebcam: function(callback, options) {
		navigator.getUserMedia  = navigator.getUserMedia ||
                                navigator.webkitGetUserMedia ||
                                navigator.mozGetUserMedia ||
                                navigator.msGetUserMedia;

        if(!navigator.getUserMedia) {
        	console.error('> SQR.Loader - getUserMedia not supported');
        	callback();
        }

        options = options || {
        	audio: false,
	        video: {
	        	// mandatory: { minWidth: 1920, minHeight: 1080 }
	        }
	    };

	    var onVideo = function(stream) {
	    	video.stream = stream;
			video.src = window.URL.createObjectURL(stream);
	        video.play();
	        video.addEventListener('canplaythrough', videoReady, false);
	    }

	    var videoReady = function() {
	    	callback(video, 'webcam');
	    }

        var video = document.createElement('video');
    	video.autoplay = true;

		navigator.getUserMedia(options, onVideo, function(e) { 
			console.error('> SQR.Loader - getUserMedia error ', e);
		});
    },

    /**
	 *	@method loadVideo
	 *	@memberof SQR.Loader
	 *
     *	@description Preload a video so that it can be used as a texture (typically)
     */
    loadVideo: function(path, callback) {
    	var videoReady = function() {
	    	callback(video, path);
	    }

    	var video = document.createElement('video');
    	video.autoplay = true;
    	video.addEventListener('canplaythrough', videoReady, false);


    	var p = path;

    	if(!video.canPlayType('video/mp4')) {
    		p = p.replace('mp4', 'webm');
    	}

    	video.src = p;
    },

    /**
	 *	@method loadAssets
	 *	@memberof SQR.Loader
	 *
     *	@description Load multiple assets of type:
     *  <ul>
     *		<li>text, including GLSL code</li>
     *		<li>JSON, including model, geometry, scene. etc...</li>
     *		<li>image (jpg, gif, png), video (mp4, webm)</li>
     *		<li>webcam (it will initiate the webcam,
     *		ask user for permisions, and return a ready to use stream)</li>
     *	</ul>
	 *	
	 *	Each file will be availabke from the asset object passed to the callback
	 *	under it's name, ex. assets['normal2color.glsl']
	 *	It's also possible ot specify an alias. Instead of a String, 
	 *	use an Array, where [0] is the path, and [1] is the alias.
     *
     *	@example
SQR.Loader.loadAssets([
	['some-image.jpg', 'image'],
	['some-video.mp4', 'video'],
	['a-shader.glsl', 'shader'],
	'another-shader.glsl',
	'webcam' // special case, but useful :)
], function(assets) {
	var image = assets['image'];
});
	 *
	 * 	@param {object} paths - list of file paths (with optinal aliases) to load, as in example below.
	 *	@param {function} callback - called when all the files are loaded. 
	 *	The assets are passed as argument as in the example below.
	 *	@param {function} progressCallback - called each time when on of the files is loaded
     */
	loadAssets: function(paths, callback, progressCallback) {
		var toLoad = paths.length;
		SQR.Loader.assets = {};
		var aliases = {};

		var onAsset = function(asset, p) {
			SQR.Loader.assets[aliases[p] || p] = asset;
			toLoad--;

			if(progressCallback) {
				progressCallback(toLoad, paths.length);
			}

			if(toLoad == 0) {
				callback(SQR.Loader.assets);
			}
		}
		
		for(var i = 0; i < toLoad; i++) {
			var p = paths[i];

			if(typeof(p) != 'string') {
				aliases[p[0]] = p[1];
				p = p[0];
			}

			var e = p.substring(p.lastIndexOf('.') + 1);

			if(p.indexOf('~') > -1) {
				if(SQR.GLSL && SQR.GLSL[p.substring(2)]) {
					toLoad--;
					continue;
				} else {
					p = p.replace('~', SQR.shaderPath);
				}
			}
			
			switch(e) {
				case 'glsl':
					SQR.Loader.loadText(p, onAsset);
					break;
				case 'png':
				case 'jpg':
				case 'gif':
					SQR.Loader.loadImage(p, onAsset);
					break;
				case 'json':
				case 'js':
					SQR.Loader.loadJSON(p, onAsset);
					break;
				case 'mp4':
				case 'webm':
					SQR.Loader.loadVideo(p, onAsset);
					break;
				case 'webcam':
					SQR.Loader.loadWebcam(onAsset);
					break;
			}
		}
	}
};








/* --- --- [common/Renderer.js] --- --- */

/**
 *	@class Renderer
 *	@memberof SQR
 *
 *	@description Represents the rendering engine
 */
SQR.Renderer = function(context) {

	var r = {};
	var uniforms = {}, renderObjects = [], transparentObjects = [];

	var updateTransform = function(t) {
		if(!t.active) return;

		t.transformWorld();
		
		if (t.numChildren > 0) {
            for (var i = 0; i < t.numChildren; i++) {
                updateTransform(t.children[i]);
            }
        }

        if(t.buffer && t.shader) {
        	if(t.transparent) transparentObjects.push(t);
        	else renderObjects.push(t);
        }
	}

	var lastBuffer, lastShader, shaderChanged, bufferChanged;

	var defOpts = {};

	r.render = function(root, camera, options) {
		var gl = SQR.gl;

		options = options || defOpts;

		if(!options.dontClear) context.clear();

		gl.disable(gl.BLEND);
		gl.enable(gl.DEPTH_TEST);
		gl.enable(gl.CULL_FACE);
        gl.frontFace(gl.CW);

		renderObjects.length = 0;
		transparentObjects.length = 0;
		
		updateTransform(root);

		if(camera) {
			camera.computeInverseMatrix();
		}

		renderObjects = renderObjects.concat(transparentObjects);

		var objectsToRender = renderObjects.length, ro, 
			lastBuffer = null, 
			lastShader = null,
			transparentRendering = false;
		

		var hasReplacementShader = options && options.replacementShader;

		if(hasReplacementShader) {
			lastShader = options.replacementShader.use();
		}

		for(var i = 0; i < objectsToRender; i++) {

			shaderChanged = false, bufferChanged = false;

			var ro = renderObjects[i];

			ro.transformView(camera ? camera.inverseWorldMatrix : null);

			if(ro.transparent) {

				if(!transparentRendering) {
					gl.enable(gl.BLEND);
					transparentRendering = true;
				}
				
				gl.blendFunc(ro.srcFactor, ro.dstFactor);
			}

			if(lastBuffer != ro.buffer) {
				lastBuffer = ro.buffer;
				lastBuffer.bind();
				bufferChanged = true;
			}

			if((lastShader != ro.shader) && !hasReplacementShader) {
				lastShader = ro.shader.use().updateTextures();
				var p = (camera && camera.projection) || r.projection;
				if(p) lastShader.setUniform('uProjection', p);
				shaderChanged = true;
			}

			if(shaderChanged || bufferChanged) {
				lastShader.attribPointers(lastBuffer);
			}

			ro.draw(options);
		}

	}

	r.renderToScreen = function() {
		var gl = SQR.gl;
		gl.bindFramebuffer(gl.FRAMEBUFFER, null);
	}

	return r;

}

/* --- --- [common/Shader.js] --- --- */

/**
 *	@class Shader
 *	@memberof SQR
 *
 *	@description Represents a GLSL shader. The shader class takes the source GLSL code,
 *	compiles it and extracts all the attributes and uniforms. It also exposes
 *	methods to set the uniform values of this shader.
 *
 *	Please read the {@tutorial basic-setup} tutorial to see how to use a shader  
 *	and the {@tutorial understanding-shaders} tutorial for an in depth discussion on shaders.
 *
 *
 *	@param {string} source - the GLSL source code formatted 
 *	in a way to include both vertex and fragment shaders.
 *
 *	@param {object} options - additional options, not required. Supported options in the code sample below.
 *
 *	@example
{
	// Do not compile 
	// (most of the time this is not necessary)
	doNotCompile: true,

	// Preprocesor directives. 
	// This object will create 
	// the following directives, attached to both
	// vertex and fragment shaders:
	// #define COLOR_ONLY
	// #define COLOR 1.0 0.0 0.0
	directives: [
	    { name: 'COLOR_ONLY' },
	    { name: 'COLOR', value: '1.0, 0.0, 0.0' }
	]
}
 */
SQR.Shader = function(source, options) {

	var s = {}, program, gl;
	var attributes = {}, attrList = [];
	var uniforms = {}, uniformList = [], uniformTextures = [];

	var parseGLSL = function(s) {

		if(!s) throw "> SQR.Shader.parseGLSL - Shader source code missing";

		var pp = "", pv = options ? options.directives : null;

		if(pv && pv instanceof Array) {
			for(var i = 0; i < pv.length; i++) {
				pp += "#define " + pv[i].name;
				if(pv[i].value) pp += " " + pv[i].value;
				pp += "\n";
			}
		} 

		var vertex = pp, fragment = pp;
		var isVertex = true;

		var ls = s.split("\n");

		for(var i = 0; i < ls.length; i++) {
			var l = ls[i];

			if (l.indexOf("//#include") > -1) {
				var p = l.substring(11), inc;

				if(SQR.GLSL && SQR.GLSL[p.substring(1)]) {
					inc = SQR.GLSL[p.substring(1)];
				} else {
					inc = SQR.Loader.assets[p.replace('~', SQR.shaderPath)];
				}

				if(!inc) throw "> SQR.Shader.parseGLSL - Include not found " + p;
				ls[i] = inc;
			}
		}

		var ls = ls.join('\n').split('\n');

		for(var i = 0; i < ls.length; i++) {
			var l = ls[i];
			if(l.indexOf("//#") > -1) {
				if (l.indexOf("//#fragment") > -1) {
					isVertex = false;
				} else if (l.indexOf("//#vertex") > -1) {
					isVertex = true;
				}  
			} else {
				if(l.indexOf("//") > -1) l = l.substring(0, l.indexOf("//"));

				if(l.match(/^([\s\t]*)$/)) continue;

				if(isVertex) {
					vertex += l + "\n";
				} else {
					fragment += l + "\n";
				}
			}
		}

		return { vertex: vertex, fragment: fragment };
	};

	s.compile = function() {
		var sc = source = parseGLSL(source);
		var gl = SQR.gl;
		var vs = gl.createShader(gl.VERTEX_SHADER);
        gl.shaderSource(vs, sc.vertex);
        gl.compileShader(vs);
         
        var fs = gl.createShader(gl.FRAGMENT_SHADER);
        gl.shaderSource(fs, sc.fragment);
        gl.compileShader(fs);
         
        program = gl.createProgram();
        gl.attachShader(program, vs);
        gl.attachShader(program, fs);
        gl.linkProgram(program);

        if(!gl.getShaderParameter(vs, gl.COMPILE_STATUS)) 
        	throw "> SQR.Shader. Vertex shader compile error: " + gl.getShaderInfoLog(vs);

        if(!gl.getShaderParameter(fs, gl.COMPILE_STATUS)) 
        	throw "> SQR.Shader. Fragment shader compile error: " + gl.getShaderInfoLog(fs);

        if(!gl.getProgramParameter(program, gl.LINK_STATUS)) 
        	throw "> SQR.Shader. Shader linking error: " + gl.getProgramInfoLog(program);

        return s;
	}

	s.inspect = function() {
		var gl = SQR.gl;
	    var numAttr = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);

	    for (var i = 0; i < numAttr; i++) {
	        var a = gl.getActiveAttrib(program, i);
	        a.location = gl.getAttribLocation(program, a.name);
	        attributes[a.name] = a;
	        attrList.push(a);
	    }

	    var numUni = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS), id = 0;

	    for (var i = 0; i < numUni; i++) {
	        var u = gl.getActiveUniform(program, i);
	        u.location = gl.getUniformLocation(program, u.name);

	        if(u.type == gl.SAMPLER_2D || u.type == gl.SAMPLER_CUBE) {
	        	u.texId = id++;
	        	uniformTextures.push(u);
	        }

	        uniforms[u.name] = u;
	        uniformList.push(u);
	    }

	    return s;
	}

	var stringType = 'string';

	s.getUniform = function(name) {
		return uniforms[name];
	}

	s.hasUniform = function(name) {
		return uniforms[name] != null;
	}

	s.setUniform = function(uniform, value) {
		var gl = SQR.gl;
		var n = (typeof uniform == stringType) ? uniforms[uniform] : uniform;
		var v = value;

		if(!n) {
			if(SQR.WARN_UNIFORM_NOT_PRESENT) {
				console.warn("> SQR.Shader attempt to set uniform that does not exist: " + uniform);
				console.trace();
			}
			return s;
		}

		if(v.toUniform) v = v.toUniform(n.type);

		switch (n.type) {
			case gl.BYTE:
				gl.uniform1i(n.location, v);
				break;
			case gl.UNSIGNED_BYTE:
				gl.uniform1i(n.location, v);
				break;
			case gl.SHORT:
				gl.uniform1i(n.location, v);
				break;
			case gl.UNSIGNED_SHORT:
				gl.uniform1i(n.location, v);
				break;
			case gl.INT:
				gl.uniform1i(n.location, v);
				break;
			case gl.INT_VEC2:
				gl.uniform2iv(n.location, v);
				break;
			case gl.INT_VEC3:
				gl.uniform3iv(n.location, v);
				break;
			case gl.INT_VEC4:
				gl.uniform4iv(n.location, v);
				break;
			case gl.UNSIGNED_INT:
				gl.uniform1i(n.location, v);
				break;
			case gl.FLOAT:
				gl.uniform1f(n.location, v);
				break;
			case gl.FLOAT_VEC2:
				gl.uniform2fv(n.location, v);
				break;
			case gl.FLOAT_VEC3:
				gl.uniform3fv(n.location, v);
				break;
			case gl.FLOAT_VEC4:
				gl.uniform4fv(n.location, v);
				break;
			case gl.BOOL:
				gl.uniform1i(n.location, v);
				break;
			case gl.BOOL_VEC2:
				gl.uniform2iv(n.location, v);
				break;
			case gl.BOOL_VEC3:
				gl.uniform3iv(n.location, v);
				break;
			case gl.BOOL_VEC4:
				gl.uniform4iv(n.location, v);
				break;
			case gl.FLOAT_MAT2:
				gl.uniformMatrix2fv(n.location, false, v.data || v);
				break;
			case gl.FLOAT_MAT3:
				gl.uniformMatrix3fv(n.location, false, v.data || v);
				break;
			case gl.FLOAT_MAT4:
				gl.uniformMatrix4fv(n.location, false, v.data || v);
				break;
			case gl.SAMPLER_2D:
				setTexture(n, v);
				break;
			case gl.SAMPLER_CUBE:
				setTextureCube(n, v);
				break;
			default:
				console.warn("> SQR.Shader > WARNING! Unknown uniform type ( 0x" + n.type.toString(16) + " )");
				break;
		}

		return s;
	}

	var setTexture = function(uniform, texture) {
		var gl = SQR.gl, id = uniform.texId;
		uniform.texref = texture;
	    gl.activeTexture(gl.TEXTURE0 + id); // 33984
		gl.bindTexture(gl.TEXTURE_2D, texture.tex || texture);
		if(texture.isAnimated) texture.update();
		gl.uniform1i(uniform.location, id);
	}

	var setTextureCube = function(uniform, texture) {
		var gl = SQR.gl, id = uniform.texId;
		uniform.texref = texture;
	    gl.activeTexture(gl.TEXTURE0 + id);
		gl.bindTexture(gl.TEXTURE_CUBE_MAP, texture.tex || texture);
		gl.uniform1i(uniform.location, id);
	}

	s.updateTextures = function() {
		var gl = SQR.gl;
		for(var i = 0, tl = uniformTextures.length; i < tl; i++) {
			var t = uniformTextures[i];
			if(t.texref) s.setUniform(t, t.texref);
		}
		return s;
	}

	s.use = function() {
		SQR.gl.useProgram(program);
		return s;
	}

	s.attribPointers = function(geo) {
		var gl = SQR.gl, al = attrList.length;
		geo = geo.buffer || geo;
		for(var i = 0; i < al; i++) {
			var a = attrList[i];
		 	var ga = geo.attributes[a.name];
		 	if(!ga) throw "> SQR.Shader expects attribute " + a.name + " but geometry doesn't provide it";
		 	if(!a.enabled) gl.enableVertexAttribArray(a.location);
			gl.vertexAttribPointer(a.location, ga.size, gl.FLOAT, false, geo.strideByteSize, ga.byteOffset);
			a.enabled = true;
		}
		return s;
	}


	if(!options || !options.doNotCompile) {
		s.compile();
		s.inspect();
	}

	return s;

}

/* --- --- [common/Texture.js] --- --- */

/**
 *  @class Texture
 *  @memberof SQR
 *
 *  @description Represents a WebGL texture created from an Image, Video or Canvas element.
 */
SQR.Texture = function(s, options) {

    options = options || {};

    if(!(s instanceof HTMLVideoElement || s instanceof Image || s instanceof HTMLCanvasElement)) {
        console.error('Invalid source: ' + s);
        throw 'SQR.Texture > provided source is not a valid source for texture';
    }

	var t = {};
	var gl = SQR.gl;
	var source = s;
	var texture = gl.createTexture();

	t.isAnimated = (options && options.isAnimated) || (s instanceof HTMLVideoElement);

	var isPowerOfTwo = function() {
        var x = source.width, y = source.height;
        return x > 0 && y > 0 && (x & (x - 1)) == 0 && (y & (y - 1)) == 0;
    }

	t.update = function() {
		var gl = SQR.gl;
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, source);
        return t;
	}

    var wrapS = options.wrapS || options.wrap || gl.CLAMP_TO_EDGE;
    var wrapT = options.wrapT || options.wrap || gl.CLAMP_TO_EDGE;

    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, source);

    var mif, mgf;

    if(isPowerOfTwo()) {
        gl.generateMipmap(gl.TEXTURE_2D);
        mif = gl.LINEAR_MIPMAP_LINEAR, mgf = gl.LINEAR;
    } else {
        mif = mgf = gl.LINEAR;
    }

    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, mgf);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, mif);

    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, wrapS);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, wrapT);
    gl.bindTexture(gl.TEXTURE_2D, null);

    t.tex = texture;

	return t;

}

/* --- --- [common/Transform.js] --- --- */

/**
 *  @class Transform
 *  @memberof SQR
 *
 *  @description A transform is a basic building block for 3D scenes made with squareroot.js
 * 
 *  @param name {string} the name of the transform.
 */
SQR.Transform = function(name) {

	var t = {};

	var inverseWorldMatrix;
    var transformState = 0;

    /**
     *  @var {string} name - a unique name of this transform, useful for debugging
     *  @memberof SQR.Transform.prototype
     *  @default `sqr.transform.` + a counter (ex. `sqr.transform.29)
     */
    t.name = name || 'sqr.transform.' + SQR.TransformCount++;

    /** 
     *  @var {boolean} active - is set to false, the transform and 
     *  all it's children will not be rendered.
     *  @memberof SQR.Transform.prototype
     *  @default false
     */
    t.active = true;

    /**
     *  @var {boolean} directMatrixMode - if set to true, position, rotation/quaternion and scale will be ignored
     *  @memberof SQR.Transform.prototype
     *
     *  @description When set to true matrix value inside @this.matrix can be manipulated directly.
     *
     *  @default false
     */
    t.directMatrixMode = false;
    

    /** 
     *  @var {SQR.Matrix44} matrix - object-to-parent transformation matrix
     *  @memberof SQR.Transform.prototype
     */
    t.matrix = new SQR.Matrix44();
    
    /** 
     *  @var {SQR.V3} position - the position of this transform relative to it's parent
     *  @memberof SQR.Transform.prototype
     */
	t.position = new SQR.V3();

    /** 
     *  @readonly 
     *  @var {SQR.V3} globalPosition - the global position of this transform (set automatically)
     *  @memberof SQR.Transform.prototype
     */
    t.globalPosition = new SQR.V3();

    /**
     *  @var {SQR.Quaternion} quaternion - A Quaternion that describes the rotation of the transform, 
     *  only active if `useQuaternion` is set to true.
     *  @memberof SQR.Transform.prototype
     */
	t.quaternion = new SQR.Quaternion();

    /**
     *  @var {SQR.V3} rotation - A 3D vector the describes the rotation of the transform in Euler angles, 
     *  disabled if `useQuaternion` is set to true.
     *  @memberof SQR.Transform.prototype
     */
	t.rotation = new SQR.V3();

    /**
     *  @var {SQR.V3} scale - the scale of the object on x, y and z axis
     *  @memberof SQR.Transform.prototype
     */
	t.scale = new SQR.V3(1, 1, 1);

    /**
     *  @var {SQR.Quaternion} useQuaternion - if set to true, 
     *  will use `quaternion` for rotation instead of the Euler angles in `rotation`
     *  @memberof SQR.Transform.prototype
     *  @default false
     */
	t.useQuaternion = false;

    /**
     *  @var {boolean} isStatic
     *  @description Any object can have two different positioning modes: dynamic or static.
     *  If this value is set to false (dynamic) the matrices 
     *  for this object will be recalculated at each frame.<br>
     *  If this value is set to true (static) the matrices for 
     *  this object will be recalculated only once.
     *  @memberof SQR.Transform.prototype
     *  @default false
     */
    t.isStatic = false;

    
	t.normalMatrix = new SQR.Matrix33();
	t.globalMatrix = new SQR.Matrix44();
    t.viewMatrix = new SQR.Matrix44();
    t.inverseWorldMatrix;

    t.lookAt = null;

    t.transparent = false;
    t.srcFactor = null;
    t.dstFactor = null;

    t.setBlending = function(transparent, src, dst) {
        t.transparent = transparent;
        // By default blend the object on top with the object on the bottom
        t.srcFactor = src || SQR.gl.SRC_ALPHA;
        t.dstFactor = dst || SQR.gl.ONE_MINUS_SRC_ALPHA;
    } 

	t.children = [], t.numChildren = 0;

   /**
    *   @method add
    *   @memberof SQR.Transform.prototype
    *   
    *   @description Add a child transform. Accepts multiple arguments but all of them need to be of type {SQR.Transform}.
    *   It doesn't do any sort of type checking so if you add non object that are not {SQR.Transform} 
    *   it will result in errors when the scene is rendered.
    */
    t.add = function() {
        for (var i = 0; i < arguments.length; i++) {
            var c = arguments[i];
            c.parent = t;
            if (t.children.indexOf(c) == -1) t.children.push(c);
        }
        t.numChildren = t.children.length;
        return t;
    }

    /**
     *  @method remove
     *  @memberof SQR.Transform.prototype
     *   
     *  @description Removes a child transform. Accepts multiple arguments 
     *  but all of them need to be of type {SQR.Transform}
     */
    t.remove = function() {
        for (var i = 0; i < arguments.length; i++) {
            var c = arguments[i];
            var j = t.children.indexOf(c);
            if (j == -1) return false;
            c.parent = null;
            t.children.splice(j, 1);
        }
        t.numChildren = t.children.length;
        return t;
    }
    
    /**
     *  @method removeAll
     *  @memberof SQR.Transform.prototype
     *   
     *  @description Removes all children transform.
     */
    t.removeAll = function() {
        t.children.length = 0;
        t.numChildren = 0;
    }

    /**
     *  @method contains
     *  @memberof SQR.Transform.prototype
     *   
     *  @description Checks if transform is child of this transfom
     *  @param {SQR.Transform} c the transform to look for
     */
    t.contains = function(c) {
        return t.children.indexOf(c) > -1;
    }

    /**
     *  @method recurse
     *  @memberof SQR.Transform.prototype
     *   
     *  @description Execute this function on all the child transforms including this current one.
     *
     *  @param {function} f the function that will be called on each child. 
     *  This function will receive the transform as argument.
     *
     *  @param {boolean} excludeSelf if set to true, the function will only be called for all 
     *  the ancestors of the Transform.
     */
    t.recurse = function(f, excludeSelf) {
       if(!excludeSelf) f(t);
        for (var i = 0; i < t.numChildren; i++) {
            t.children[i].recurse(f);
        }
    }

    t.draw = function(options) {
        var isReplacementShader = options && options.replacementShader;
        var shader = isReplacementShader ? options.replacementShader : t.shader;

        shader.setUniform('uMatrix', t.globalMatrix);
        shader.setUniform('uViewMatrix', t.viewMatrix);
        shader.setUniform('uNormalMatrix', t.normalMatrix);

        if(!isReplacementShader && shader.uniforms) {
            var un = Object.keys(shader.uniforms);
            for(var i = 0, l = un.length; i < l; i++) {
                shader.setUniform(un[i], shader.uniforms[un[i]]);
            }
        }

        if(!isReplacementShader && t.uniforms) {
            var un = Object.keys(t.uniforms);
            for(var i = 0, l = un.length; i < l; i++) {
                shader.setUniform(un[i], t.uniforms[un[i]]);
            }
        }

    	t.buffer.draw();
    }

	/**
     * Sets up the local matrix and multiplies is by the parents globalMatrix.
     * This function is called in the rendering process, do not call directly.
     *
     */
    t.transformWorld = function() {

        if(transformState == 1) return;

        if(!t.directMatrixMode) {
        	var p = t.position;
            var s = t.scale;
            
            if (t.useQuaternion) {
                var q = t.quaternion;
            	t.matrix.setTQS(p.x, p.y, p.z, q.w, q.x, q.y, q.z, s.x, s.y, s.z);
           	} else {
                var r = t.rotation;
    			t.matrix.setTRS(p.x, p.y, p.z, r.x, r.y, r.z, s.x, s.y, s.z);
            }
        }

        if(t.lookAt) {
            t.matrix.lookAt(t.lookAt.position);
        }

        if (t.parent) {
            t.parent.globalMatrix.copyTo(t.globalMatrix);
            t.globalMatrix.multiply(t.matrix);
        } else {
            t.matrix.copyTo(t.globalMatrix);
        }

        t.globalMatrix.extractPosition(t.globalPosition);

        if(t.isStatic) transformState = 1;
    }

    /** 
     *  Used for sorting object in the rendering function
     *  (not implemented yet)
     */
    t.viewDepth = function() {
        return t.viewMatrix.data[14];
    }

    /**
     * Calculate the view matrix.
     *
     * This function is called in the rendering process, do not call directly.
     *
     * @param inverseCamMatrix {SQR.Matrix44} the inverse matrix of the camera
     */
    t.transformView = function(inverseCamMatrix) {
        if(inverseCamMatrix) {
            inverseCamMatrix.copyTo(t.viewMatrix);
            t.viewMatrix.multiply(t.globalMatrix);
            t.viewMatrix.inverseMat3(t.normalMatrix);
        } else {
            t.globalMatrix.copyTo(t.viewMatrix);
            t.viewMatrix.inverseMat3(t.normalMatrix);
        }
        
    }

	/**
     * Calculate the camera inverse matrix.
     *
     * Used only if this transform is a camera.
     *
     * This function is called in the rendering process, do not call directly.
     */
    t.computeInverseMatrix = function() {
    	if(!t.inverseWorldMatrix) {
            t.inverseWorldMatrix = new SQR.Matrix44();
        }
        t.globalMatrix.inverse(t.inverseWorldMatrix);
        return t.inverseWorldMatrix;
    }

	return t;

}

SQR.TransformCount = 0;








